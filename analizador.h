// Class automatically generated by Dev-C++ New Class wizard

#ifndef ANALIZADOR_H
#define ANALIZADOR_H

#include "instrumento.h" // inheriting class's header file
#include <FL/Fl.H>
//#include "fl_Knob.h"
#include <FL/Fl_Dial.H>
#include <FL/Fl_Group.H>
#include <Fl/fl_Light_Button.h>
#include <Fl/fl_Button.h>
#include <FL/Fl_Repeat_Button.H>
#include <FL/fl_ask.H>
#include <FL/Fl_Value_Output.H>
#include <FL/Fl_Scrollbar.H>
#include <FL/Fl_Spinner.H>
#include "Fl_Scope.h"
#include "cursores.h"
#include "grid.h"
#include "mensajes.h"
#include <FL/Fl_Group.H>
//#include <FL/Fl_Shared_Image.H>
//#include <FL/Fl_JPEG_Image.H>
#include <FL/Fl_Text_Display.H>
#include <FL/Fl_Output.H>
//#include <FL/Fl_Box.H>
#include <FL/Fl_Check_Button.H>
#include <FL/Fl_Value_Slider.H>
#include <FL/Fl_Slider.H>
#include <FL/Fl_Choice.H>
#include <FL/Fl_Help_Dialog.h>

#include <iostream>
#include <fstream>
#include <string>
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <math.h>

#include <FL/Fl_Shared_Image.H>
#include <FL/Fl_PNG_Image.H>
#include <FL/Fl_Box.H>

#include <windows.h> 

#define TAM_ALMACENADO 40
#define ESPERA_TRIGGER 20


using namespace std;

/*******************************************************************************
 * Analizador: Clase que representa las funciones del instrumento Analizador
 *             Lógico.
 * El instrumento puede capturar el estado binario de un bus de señales digitales 
 * de 8 canales y el hardware lo envía en un dato hexadecimal de 2 carácteres.
 * TAM_ALMACENADO: Constante que representa el número máximo de muestras que 
 *                 puede almacenar el instrumento.
 * El instrumento tiene 2 modos de captura:
 * 1.  Modo de captura sin disparo: El instrumento capturará el numero de 
 *                                  muestras especificado sin ningún tipo de
 *                                  condición.
 * 2. Modo de captura con disparo: El usario configura un estado de flanco de
 *                                 subida o bajada en alguno de los 8 canales
 *                                 para iniciar el muestreo; si despues de un
 *                                 tiempo configurado no se encontro el evento,
 *                                 el instrumento tomará las muestras.
 * Las muestras se realizarán de acuerdo a una frecuencia configurada por el
 * usuario.
 * El instrumento cuenta con un cursor que ayuda al usuario a interpretar el 
 * dato muestreado en un instante de tiempo y ver su representación en 3 siste-
 * mas de numeración: binaria, decimal y hexadecimal, que el usuario selecciona
 * en  un menú.
*******************************************************************************/
class Analizador : public Instrumento {
	public:
        // class constructor
		Analizador();
		// class destructor
		~Analizador();
		//Número de muestras que se pueden almacenar.
	    int inumMuestras;
	    // Ventana de ayuda de uso del instrumento.
        //Fl_Help_Dialog *manualAnalizador; 
		//Contador de datos almacenados en el arreglo
	    int idatapos;
	    //Arreglo donde se almacenan las muestras en cadenas de caracteres de datos binarios de 8 bists
	    char pdataAnalizador [TAM_ALMACENADO][9];
        //Objetos de la clase scope que representa la pantalla del analizador donde se grafica la señal digital.
		Fl_Scope *apantallaCh1, *apantallaCh2, *apantallaCh3, *apantallaCh4, *apantallaCh5,
                 *apantallaCh6, *apantallaCh7, *apantallaCh8;
        //Cursor para identificar el dato graficado
	    Cursores *ocursor; 
        //Grilla del analizador 
		grid*  ogrilla;       
	    //Número de la muestra.
        Mensajes *otextoMuestra; 
        //Botón para activar el disparo por flanco de subida
	    Fl_Button *oflancosubida;
	    //Botón para activar el disparo por flanco de bajada
	    Fl_Button *oflancobajada;
        // Botón para seleccionar el canal con el que se activa el disparo por flancos
        Fl_Spinner *oselector;
        //Agrupa los botones e indicadores del analizador
	    Fl_Group *ogroup_ana;
	    //Box para colocar la mascara del multímetro.
	    Fl_Box *oboxAna;
	    //Mascara del analizador.
	    Fl_PNG_Image *ianaliza;
	    //Contiene el nombre del instrumento
	    //Fl_Box *obox_nombre;
        //Botón para prender/apagar el instrumento analizador
        Fl_Button *oana_on;
        Fl_PNG_Image *iOnAnalizador;
        Fl_Box *oboxOnAnalizador;
        //Botón para iniciar el muestreo en el instrumento analizador
        Fl_Light_Button *omuestrear_on;
        // Botón para activar la grilla en el instrumento 
        //Fl_Light_Button *ogrilla_on;
        Fl_Button *ogrilla_on;
        Fl_PNG_Image *igrilla;
        Fl_Box *oboxgrilla;
        // Botón que habilita el almacenamiento de datos en archivos planos de texto.
        Fl_Button *olog_ana;
        //Botón que habilita la ayuda para el uso del instrumento.
        Fl_Button *ohelp_ana;
        //Boton que habilita la ayuda flotante para el uso de los botones. 
        Fl_Check_Button *oayuda_ana;
        //Selector del tipo de representación del dato graficado. 
        Fl_Choice *orep_dato;
        //Selector de la frecuencia de muestreo del analizador. 
        Fl_Choice *ofrec_muestreo;
        //Scroll para desplazar los datos graficados.  
        Fl_Scrollbar *oscroll;
        //Fl_Slider *oscroll;
        //Botón para desplazar la grafica horizontalmente  
        //Fl_Knob *odes_horizontal;
        Fl_Dial *odesHorizontal;
	    //Agrupa las herramientas e indicadores del analizador
        //Fl_Group *ogroup_ana_botones;
        //Ventana de opciones de trigger.
	    Fl_Box *obox_trigger;
	    //Agrupa las herramientas e indicadores del analizador
        Fl_Group *ogroup_trigger;
        //Botón para cerrar la ventana de opciones de trigger. 
        Fl_Button *ocerrar_trigger;
	    // Boton para activar el muestreo en el instrumento con o sin trigger
        Fl_Light_Button *otrigger_on;
		//Callback del botón de encendido del analizador. 
		static void cb_ana_on(Fl_Widget*, void *);
		inline void cb_ana_on_in();
		//Callback del botón para activar o desactivar la grilla en la pantalla del analizador
		static void cb_grilla(Fl_Widget*, void *);
		inline void cb_grilla_in();
		//Callback del botón que desplaza las graficas horizontalmente
		static void cb_horizontal(Fl_Widget*, void *);
		inline void cb_horizontal_in();
		//Callback del botón que despliega las opciones del trigger 
		static void cb_trigger_on(Fl_Widget*, void *);
		inline void cb_trigger_on_in();
		//Callback del botón que cierra la ventana de opciones del trigger
		static void cb_cerrar_trigger(Fl_Widget*, void *);
		inline void cb_cerrar_trigger_in();
		//Callback del botón que habilita el muestreo en el analizador
		static void cb_muestrear(Fl_Widget*, void *);
		inline void cb_muestrear_in();
		//Callback del botón que activa el trigger por flanco de subida
		static void cb_subida(Fl_Widget*, void *);
		inline void cb_subida_in();
		//Callback del boton que activa el trigger por flanco de bajada
		static void cb_bajada(Fl_Widget*, void *);
		inline void cb_bajada_in();
		//Callback del scroll que dezplaza el cursor del instrumento
		static void cb_scroll_cursor(Fl_Widget*, void *);
		inline void cb_scroll_cursor_in();
		//Método que recorre el arreglo pdataAnalizador[] y gráfica sus datos en los canales en pantalla
		void graficar_datos();
		
  private:
         //Callback del botón que activa la ayuda del instrumento  
         static void cb_help(Fl_Widget*, void *);
         inline void cb_help_in();
         //Callback del botón que activa el almacenamiento en archivos planos los datos capturados para el analizador lógico   
		 static void cb_log_ana(Fl_Widget*, void *);
		 inline void cb_log_ana_in(); 
         //Callback del timer para realizar la solicitud de datos del analizador logico al hardware.  
         static void cb_timer_ana(void *);
         inline void cb_timer_ana_in();
         //Callback de la primera frecuencia de muestreo del analizador 
		 static void cbfrec1(Fl_Widget*, void *);
		 inline void cbfrec1_in();
		 //Callback de la segunda frecuencia de muestreo del analizador 
		 static void cbfrec2(Fl_Widget*, void *);
		 inline void cbfrec2_in();
		 //Callback de la tercera frecuencia de muestreo del analizador 
		 static void cbfrec3(Fl_Widget*, void *);
		 inline void cbfrec3_in();
		 //Callback de la cuarta frecuencia de muestreo del analizador 
		 static void cbfrec4(Fl_Widget*, void *);
		 inline void cbfrec4_in();
         //Método que separa los datos enviados desde el hardware para cada canal del analizador logico.
		void separar_canales();
		// Número de datos representados en la pantalla. 
		int igraf_datos;
		//Arreglo que almacena el nible más significativo recibido en binario. 
		char  recibido_msb[5],recibido_msb2[5];
		//Arreglo que almacena el nible menos significativo recibido en binario. 
		char  recibido_lsb[5], recibido_lsb2[5];
		//Valor de 8 bits actual recibido en binario. 
		char  cbyte_actual[9];
		//Estado del trigger del dispositivo. 
		bool btrigger;
		//Estado del muestreo del analizador. 
		bool bmuestreando;
		//Estado del timer que espera el trigger del dispositivo. 
		bool btimer_trigger;
		//Método para determinar si ocurrio el evento que dispara el muestreo
		bool trigger();
		//Método para almacenar las muestras en el arreglopdataAnalizador[].
		void almacenar();
		//Método para convertir los datos almacenados en caracteres binarios a un dato entero.
		int bianrioadecimal(char [8]);
		//Cuadro donde se muestra el valor señalado por el cursor.
		Fl_Output *odato1;
         
};

#endif // ANALIZADOR_H

// Class automatically generated by Dev-C++ New Class wizard

#ifndef ANALIZADOR_H
#define ANALIZADOR_H

#include "instrumento.h" // inheriting class's header file
#include "Fl_7Seg.H"     // inheriting class's header file
#include <FL/Fl.H>
#include <FL/Fl_Group.H>
#include <Fl/fl_Light_Button.h>
#include <Fl/fl_Button.h>
#include <FL/Fl_Repeat_Button.H>
#include <FL/fl_ask.H>
#include <FL/Fl_Value_Output.H>
#include <FL/Fl_Scrollbar.H>
#include <FL/Fl_Spinner.H>
#include "Fl_Scope.h"
#include "cursores.h"
#include <FL/Fl_Group.H>
#include <FL/Fl_Shared_Image.H>
#include <FL/Fl_JPEG_Image.H>
#include <FL/Fl_Text_Display.H>
#include <FL/Fl_Output.H>
#include <FL/Fl_Box.H>
#include <FL/Fl_Check_Button.H>
#include <FL/Fl_Value_Slider.H>
#include <FL/Fl_Choice.H>
#include <iostream>
#include <string>

#define TAM_ALMACENADO 4
#define ESPERA_TRIGGER 10

using namespace std;

/**
 * Esta clase representa las funcionees del instrumento
 * multimetro
 */
class Analizador : public Instrumento {
	public:
        // class constructor
		Analizador();
		// class destructor
		~Analizador();
		/**
		 * Número de muestras que se van a almacenar 
		*/
	    int inum_muestras;
		/**
		 * Contador de datos almacenados en el arreglo dinámico 
		*/
	    int idatapos;
		/**
		 * Matriz dinámica para almacenar los datos del analizador
		 */
	    //char **pdata_analizador;
	    char pdata_analizador [TAM_ALMACENADO][9];
        /**
		 * Objeto de la clase scope que representa la pantalla del analizador 
		 * donde se grafica la señal digitalizada por el canal.
		*/
		Fl_Scope *apantalla_ch1, *apantalla_ch2, *apantalla_ch3, *apantalla_ch4, *apantalla_ch5,
                 *apantalla_ch6, *apantalla_ch7, *apantalla_ch8;
         /**
		 * Agrupa los botones e indicadores del analizador
		 */
	    Cursores *ocursor;        
        /**
		 * Botón para activar el disparo por flanco de subida
		 */
	    Fl_Button *oflancosubida;
	    /**
		 * Botón para activar el disparo por flanco de bajada
		 */
	    Fl_Button *oflancobajada;
        /**
		 * Botón para seleccionar el canal con el que se activa el disparo por flancos
		*/
        Fl_Spinner *oselector;
        
        /**
		 * Agrupa los botones e indicadores del analizador
		 */
	    Fl_Group *ogroup_ana;
	    /**
		 * Contiene el nombre del instrumento
		 */
	    Fl_Box *obox_nombre;
        /**
		 * Boton para iniciar el instrumento analizador
	    */
        Fl_Light_Button *oana_on;
        /**
		 * Boton para iniciar el muestreo en el instrumento analizador
	    */
        Fl_Light_Button *omuestrear_on;
        /**
		 * Boton que habilita el almacenamiento de datos en archivos planos de 
		 * texto.
	    */
        Fl_Button *olog_ana;
        /**
		 * Boton que habilita la ayuda para el uso del instrumento. 
	    */
        Fl_Button *ohelp_ana;
 
        /**
		 * Boton que habilita la ayuda flotante para el uso de los botones. 
	    */
        Fl_Check_Button *oayuda_ana;
        /**
		 * Selector del tipo de representación del dato graficado.    
	    */  
        Fl_Choice *orep_dato;
        /**
		 * Scroll para desplazar los datos graficados.    
	    */
        Fl_Scrollbar *oscroll;
	    /**
        * Agrupa las herramientas e indicadores del analizador
        */
        Fl_Group *ogroup_ana_botones;
		/**
		 * Este método es el callback del boton de encendido
		 * del analizador debe ir acompañada de una función inline para
         * poder realizar los callbacks. 
		 */
		static void cb_ana_on(Fl_Widget*, void *);
		/**
		 * Esta función acompaña la función cb_ana_on 
		 * para realizar los llamados de callback del boton de encendido
		 * del analizador 
		 */
		inline void cb_ana_on_in();
		/**
		 * Callback del boton que habilita el muestreo en el analizador
		 */
		static void cb_muestrear(Fl_Widget*, void *);
		/**
		 * Callback del boton que habilita el muestreo en el analizador
		 */
		inline void cb_muestrear_in();
		/**
		 * 
		 */
		static void cb_subida(Fl_Widget*, void *);
		/**
		 * 
		 */
		inline void cb_subida_in();
		/**
		 * 
		 */
		static void cb_bajada(Fl_Widget*, void *);
		/**
		 * 
		 */
		inline void cb_bajada_in();
		/**
		 * 
         *  
		 */
		static void cb_mas_datos(Fl_Widget*, void *);
		/**
		 *  
		 *  
		 */
		inline void cb_mas_datos_in();
		/**
		 * Esta funcion recorre los buffers de los diferentes canales del
		 * analizador logico y grafica sus datos en los canales en pantalla
		 */
		void graficar_datos();
		
  private:

        /**
         * Este método es el callback del timer para realizar la solicitud 
         * de datos del analizador logico al hardware.  
         */   
         static void cb_timer_ana(void *);
         /**
         * Esta función acompaña la función cb_timer_ana
         * para realizar los llamados de callback del timer 
         */
         inline void cb_timer_ana_in();
         /**
         *  Timer máximo de espera del trigger
         */   
         static void cb_timer_trigger(void *);
         /**
         *  Timer máximo de espera del trigger
         */
         inline void cb_timer_trigger_in();
         /**
		 * Esta funcion separa los datos enviados desde el hardware para cada
		 * canal del analizador logico.
		 */
		void separar_canales();
		/**
		 * Número de datos representados en la pantalla. 
	     */
		int  idatos_graficados;
		/**
		 * valor msb recibido en binario. 
	     */
		char  recibido_msb[5],recibido_msb2[5];
		/**
		 * valor lsb recibido en binario. 
	     */
		char  recibido_lsb[5], recibido_lsb2[5];
		/**
		 * Valor de 8 bits actual recibido en binario. 
	     */
		char  cbyte_actual[9];
		/**
		 * Estado del trigger del dispositivo. 
	    */
		bool btrigger;
		/**
		 * Estado del muestreo del analizador. 
	    */
		bool bmuestreando;
		/**
		 * Estado del timer que espera el trigger del dispositivo. 
	    */
		bool btimer_trigger;
		/**
		 * Función para determinar si ocurrio el evento que dispara el muestreo
	    */
		bool trigger(int, char, char);
		/**
		 * Función para almacenar muestras.
	    */
		void almacenar();
		/**
		 * Control de tiempo de muestreo. 
	    */
		Fl_Value_Slider *omuestreo;
		/**
		 * Valor del dato binario de 8 bits en el 1er tiempo de muestreo 
	    */
		Fl_Output *odato1;
		/**
		 * Valor del dato binario de 8 bits en el 2do tiempo de muestreo 
	     */
		Fl_Output *odato2;
		/**
		 * Valor del dato binario de 8 bits en el 3er tiempo de muestreo 
	     */
		Fl_Output *odato3;
		/**
		 * Valor del dato binario de 8 bits en el 4to tiempo de muestreo 
	     */
		Fl_Output *odato4;
		/**
		 * Valor del dato binario de 8 bits en el 5to tiempo de muestreo 
	     */
		Fl_Output *odato5;
		/**
		 * Valor del dato binario de 8 bits en el 6to tiempo de muestreo 
	     */
		Fl_Output *odato6;
		/**
		 * Valor del dato binario de 8 bits en el 7mo tiempo de muestreo 
	     */
		Fl_Output *odato7;
		/**
		 * Valor del dato binario de 8 bits en el 8o tiempo de muestreo 
	     */
		Fl_Output *odato8;
		/**
		 * Valor del dato binario de 8 bits en el 9o tiempo de muestreo 
	     */
		Fl_Output *odato9;
		/**
		 * Valor del dato binario de 8 bits en el 10o tiempo de muestreo 
	     */
		Fl_Output *odato10;
         
};

#endif // ANALIZADOR_H

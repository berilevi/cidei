// Class automatically generated by Dev-C++- New Class wizard

#include "generador.h" // class's header file
#include <math.h>


char cfrecuencia [9];                        // Cadena de caracteres con el valor de frecuencia que se visualizará en el display

/******************************************************************************
 * Generador::Generador: Constructor de la clase Generador.
 * Se inicializan las variables y se realizan las instancias de los objetos que
 * hacen parte del instrumento y sus callbacks:
 * - Control de amplitud.
 * - Control de nivel de offset.
 * - Selectores de tipo de señal.
 * - Displays de frecuencia, amplitud y nivel de offset.
*******************************************************************************/
Generador::Generador(){

	ogroupGenerador = new Fl_Group (515,370,505,330,"");                       //Inicio de grupo de objetos que hacen parte del generador
	ogroupGenerador->box(FL_UP_BOX);
	ogroupGenerador->deactivate();
	odispGen = new Fl_7Seg(520,410,320,100,"");                                //Display 7 segmentos donde se visualiza la frecuencia configurada 
    odispGen->box(FL_EMBOSSED_FRAME);
    odispGen->color(FL_BLACK);
    odispGen->thickness(5);
    odispGen->dot_len(5);
    odispGen->align_text(FL_ALIGN_RIGHT);
    odispGen->value("000.0");
    omHz = new Fl_Box(843,420,10,10,"mHz");                                     //Indicador de escala de miliHertz
    omHz->labelsize(10);
    omHz->box(FL_ENGRAVED_BOX);
    omHz->align(FL_ALIGN_RIGHT);
    oHz = new Fl_Box(843,450,10,10,"Hz");                                       //Indicador de escala de Hertz
    oHz->labelsize(10);
    oHz->box(FL_ENGRAVED_BOX);
    oHz->align(FL_ALIGN_RIGHT);
    oMeHz = new Fl_Box(843,480,10,10,"MHz");                                    //Indicador de escala de MegaHertz
    oMeHz->labelsize(10);
    oMeHz->box(FL_ENGRAVED_BOX);
    oMeHz->align(FL_ALIGN_RIGHT);
    ohelpGen  = new Fl_Button (825,382,40,18,"Help");                          //Botón que inicia la ayuda de uso del instrumento
    ohelpGen->labelsize(10);
    
    ogroupSenal = new Fl_Group (755,520,120,170,"");                           //Inicio del grupo de botones de selección de tipo de señal
    ogroupSenal->box(FL_ENGRAVED_BOX);
	ogroupSenal->deactivate();
    oseno = new Fl_Button(780,540,70,35,"Seno");                                //Botón de selección de señal seno.
    oseno->labelsize(12);
    ocuadrada = new Fl_Button(780,585,70,35,"Cuadrada");                        //Botón de selección de señal cuadrada.
    ocuadrada->labelsize(12);
    otriangulo = new Fl_Button(780,635,70,35,"Triangulo");                      //Botón de selección de señal triángulo.
    otriangulo->labelsize(12);
    ogroupSenal->end();                                                        //Fin del grupo de botones selctores de tipo de señal.
    
    ogroupFrecuencia = new Fl_Group (885,380,130,310,"");                      //Inicio del grupo de botones de configuración de frecuencia.
    ogroupFrecuencia->box(FL_ENGRAVED_BOX);
	ogroupFrecuencia->deactivate();
    ofrecGen = new Fl_Knob (900,440,100,100,"Frecuencia");                     //Ajuste grueso de frecuencia.
    ofrecGen->color(147);
    ofrecGen->type(8);
    ofrecGen->scaleticks(0);
    ofrecGen->labelsize(9);
    ofrecGen->step(0.1);
    ofrecGen->range(0,1);
    
    ofrecGen2 = new Fl_Knob (915,565,70,70,"Ajuste Fino");                     //Ajuste fino de frecuencia.
    ofrecGen2->color(147);
    ofrecGen2->type(8);
    ofrecGen2->scaleticks(0);
    ofrecGen2->labelsize(9);
    ofrecGen2->step(0.01);
    ofrecGen2->range(0,1);
    
    oescalaFrecuencia = new Fl_Choice(890,410,120,20,"Rango");                 //Menú de escalas de frecuencia
    oescalaFrecuencia->labelsize(13);
    oescalaFrecuencia->align(FL_ALIGN_TOP);
    oescalaFrecuencia->add("1 Hz",0,(Fl_Callback *)cbFrec1,this);             
    oescalaFrecuencia->add("100 Hz",0,(Fl_Callback *)cb_frec100,this);
    oescalaFrecuencia->add("500 Hz",0,(Fl_Callback *)cb_frec500,this);
    oescalaFrecuencia->add("1 KHz",0,(Fl_Callback *)cb_frec1k,this);
    oescalaFrecuencia->add("100 KHz",0,(Fl_Callback *)cb_frec100k,this);
    oescalaFrecuencia->add("500 KHz",0,(Fl_Callback *)cb_frec500k,this);
    oescalaFrecuencia->add("1 MHz",0,(Fl_Callback *)cb_frec1m,this);
       
    ovalorFrec = new Fl_Value_Input(900,655,100,25,"");                        //Caja de texto para configurar por teclado el valor de frecuencia
    ovalorFrec->type(FL_FLOAT_INPUT);
    ogroupFrecuencia->end();                                                   //Fin del grupo de controles de frecuencia
    
    ogroupAmplitud = new Fl_Group (525,520,110,170,"");                        //Inicio del grupo de controles de amplitud
    ogroupAmplitud->box(FL_ENGRAVED_BOX);
	ogroupAmplitud->deactivate();
    oamplitud = new Fl_Knob (540,550,80,80,"Amplitud");                         //Botón de ajuste de la amplitud de la señal
    oamplitud->color(180);
    oamplitud->type(8); 
    oamplitud->scaleticks(0);
    oamplitud->labelsize(11);
    oamplitud->range(0,5);
    odispAmplitud = new Fl_Output(545,650,70,20,"");                           //Display del valor de la amplitud.
    ogroupAmplitud->end();                                                     //Fin del grupo de controles de amplitud
    
    ogroupOffset = new Fl_Group (640,520,110,170,"");                          //Inicio del grupo de controles de nivel de offset
    ogroupOffset->box(FL_ENGRAVED_BOX);
	ogroupOffset->deactivate();
    ooffset = new Fl_Knob (655,550,80,80,"Offset");                             //Perilla de ajuste de nivel de offset.
    ooffset->color(180);
    ooffset->type(8);
    ooffset->scaleticks(0); 
    ooffset->labelsize(11);
    ooffset->range(-5,5);
    odispOffset = new Fl_Output(660,650,70,20,"");                             //Display de nivel de offset
    ogroupOffset->end();                                                       //Fin del grupo de controles de nivel de offset
    
 	ogroupGenerador-> end();                                                   //Fin del grupo de controles del generador
	
	oboxNombre = new Fl_Box(520,375,254,30,"GENERADOR DE SEÑALES");            
    oboxNombre->box(FL_ENGRAVED_FRAME);
    oboxNombre->labelfont(FL_HELVETICA_BOLD);
    oboxNombre->labelsize(19);
	
	ogenOn = new Fl_Light_Button(780,375,38,30,"ON");                          //Botón para prender/apagar el generador  
    ogenOn->labelsize(9);     
    
    // Callbacks de los botones del generador de señales
    
    ogenOn->callback(cbGeneradorOn, this);
    oseno->callback(cbSeno,this);
    ocuadrada->callback(cbCuadrada,this);
    otriangulo->callback(cbTriangulo,this);
    ofrecGen->callback(cbFrecGen, this);
    ofrecGen2->callback(cbFrecgen2, this);
    oamplitud->callback(cb_amplitud, this);
    ooffset->callback(cb_offset, this);

}


/*******************************************************************************
 * Generador::cbGeneradorOn: Callback del botón que prende/apaga el generador 
 *                             de señales.
 * Al prender el instrumento se inicializa con las siguientes configuraciones 
 * por defecto:
 * Señal tipo: Seno.
 * Frecuencia de la señal: xxxxx Hz.
 * Amplitud: 5 V pico a pico.
 * Nivel de offset: 0 Voltios. 
*******************************************************************************/
void Generador::cbGeneradorOn(Fl_Widget* pboton, void *any){
     Generador* pgener=(Generador*)any;
     pgener->cbGeneradorOnIn();
}

void Generador::cbGeneradorOnIn(){
     if (ogenOn->value()== 1){
        activar(1);
        Encapsular('I','a','1','0',0x00,0x00);
        Transmision();
        if (bhardware){
           ogroupGenerador->activate();
           ogroupFrecuencia->activate();
           ogroupOffset->activate();
           oescalaFrecuencia->value(0);
           ogroupSenal->activate();
           ogroupAmplitud->activate();
           oseno->value(1);
        }
        else {
             fl_message("Error de hardware");
        }
     }
     if (ogenOn->value()== 0){
        ocuadrada->box(FL_UP_BOX);                      
        ocuadrada->value(0);
        otriangulo->box(FL_UP_BOX);                      
        otriangulo->value(0);
        activar(0);
        oseno->box(FL_UP_BOX);                      
        oseno->value(0);
        ogroupGenerador->deactivate(); 
     } 
}



/*******************************************************************************
 * Generador::cbSeno: Callback del botón que selecciona la señal tipo seno.
 * Se le envía al hardware una trama con la configuración de tipo de señal seno
 * y los otros botones de selección de tipo de señal se desactivan.
*******************************************************************************/
void Generador::cbSeno(Fl_Widget* pboton, void *any){
     Generador* pgener=(Generador*)any;
     pgener->cbSenoIn();
}

void Generador::cbSenoIn(){
     if (oseno->value()== 0){
        ocuadrada->box(FL_UP_BOX);                      
        ocuadrada->value(0);
        otriangulo->box(FL_UP_BOX);                      
        otriangulo->value(0);
        Encapsular('I','i','1','1',0x00,0x00);                                  //Trama tipo de señal seno
        Transmision();
        if (bhardware){                                                         //Si la respuesta fue ack.
           otriangulo->value(0);
           oseno->value(1);
           oseno->box(FL_DOWN_BOX);
        }
        else {
             fl_message("Error de hardware");
        }
     }
}


/*******************************************************************************
 * Generador::cbCuadrada: Callback del botón que selecciona la señal tipo 
 *                         cuadrada.
 * Se le envía al hardware una trama con la configuración de tipo de señal 
 * cuadrada y los otros botones de selección de tipo de señal se desactivan.
*******************************************************************************/
void Generador::cbCuadrada(Fl_Widget* pboton, void *any){
     Generador* pgener=(Generador*)any;
     pgener->cbCuadradaIn();
}

void Generador::cbCuadradaIn(){
     if (ocuadrada->value()== 0){
        oseno->box(FL_UP_BOX);                      
        oseno->value(0);
        otriangulo->box(FL_UP_BOX);                      
        otriangulo->value(0);
        Encapsular('I','i','1','3',0x00,0x00);                                  //Trama tipo de señal cuadrada
        Transmision();
        if (bhardware){                   
           ocuadrada->value(1);
           ocuadrada->box(FL_DOWN_BOX);
        }
        else {
             fl_message("Error de hardware");
        }
     }
}

/*******************************************************************************
 * Generador::cbTriangulo: Callback del botón que selecciona la señal tipo
 *                          triangulo.
 * Se le envía al hardware una trama con la configuración de tipo de señal 
 * triangulo y los otros botones de selección de tipo de señal se desactivan.
*******************************************************************************/
void Generador::cbTriangulo(Fl_Widget* pboton, void *any){
     Generador* pgener=(Generador*)any;
     pgener->cbTrianguloIn();
}

void Generador::cbTrianguloIn(){
     if (otriangulo->value()== 0){
        oseno->box(FL_UP_BOX);                      
        oseno->value(0);
        ocuadrada->box(FL_UP_BOX);                      
        ocuadrada->value(0);
        Encapsular('I','i','1','2',0x00,0x00);                                  //Trama de tipo de señal triángulo
        Transmision();
        if (bhardware){                   
           otriangulo->value(1);
           otriangulo->box(FL_DOWN_BOX);
        }
        else {
             fl_message("Error de hardware");
        }
     }
}


/*******************************************************************************
 * Generador::cbFrecGen: Callback del botón para seleccionar la frecuencia de 
 *                         la señal generada.
 * FACTOR: Constante por la que se multiplica el valor del botón de configurar
 *         la frecuencia, para escalarlo al valor del chip generador de señales.
 * ifrechardware: Variable entera que contiene el valor que se debe enviar al 
 *                hardware para configurar la frecuencia de la señal.
 * frecHexa: Cadena de caracteres donde se almacena el valor ifrechardware
 *            convertido en caracteres hexadecimales que se envián en la trama
 *            de configuración de fracuencia de señal.
 * Para encapsular el valor de frecuencia configurado, se recorre el arreglo de 
 * carácteres en forma inversa es decir desde el ultimo caracter hasta el primero
 * mediante un ciclo for() y se va adicionando carácter a carácter a la trama que
 * se envía al hardware: "trama_control[]". 
 * Para configurar la frecuencia, se envía en "trama_control[]" en 8 carácteres
 * hexadecimales, si el valor se representa en menos de 8 carácteres hexadecima-
 * les, el resto se rrellena con '0's.  
*******************************************************************************/
void Generador::cbFrecGen(Fl_Widget* pboton, void *any){
     Generador* pgener=(Generador*)any;
     pgener->cbFrecGenIn();
}

void Generador::cbFrecGenIn(){
    
     int ifrechardware;
     int ilong;
     char pruebafrec[10];
     ovalorFrec->value(ofrecGen->value()*5.3687);
     ifrechardware = int(FACTOR*(ofrecGen->value()+ofrecGen2->value()));
     itoa(ofrecGen->value(),cfrecuencia,10);                                  
     //odispGen->value(cfrecuencia);
     sprintf(pruebafrec, "%.6g", ofrecGen->value()); //Valor de la frecuencia guardado en formato de 6 decimales.                         
     odispGen->value(pruebafrec);
     itoa(ifrechardware,frecHexa,16);                //Conversión del valor entero en una cadena de caracteres con el valor hexadecimal.    
     ilong = strlen(frecHexa);
     for (int icont = 8; icont > 0; icont --){        //Ciclo para encapsular el valor de frecuencia configurado en la trama para enviar la hardware.
         if(ilong > 0){
            if (frecHexa[ilong-1]>60){                                                        
               frecHexa[ilong-1]=frecHexa[ilong-1]-32;  
               trama_control[icont-1]=frecHexa[ilong-1];                                                          
            }
            else{
                 trama_control[icont-1]= frecHexa[ilong-1];
            }
         }
         else{
             trama_control[icont-1] = '0'; 
         }
         ilong--;
     }
     trama_control[0] = 0x05;
     trama_control[8] = 0x00;
     Transmision();
}


/*******************************************************************************
 * Generador::cbFrecgen2: Callback del botón que realiza el ajuste fino de la
 *                         frecuencia de la señal generada.
 * Botón de ajuste fino para configurar el valor de la frecuencia de las señales
 * generadas. Ajusta el valor en un decimo del valor de la escala en la que se 
 * encuentra.
*******************************************************************************/

void Generador::cbFrecgen2(Fl_Widget* pboton, void *any){
     Generador* pgener=(Generador*)any;
     pgener->cbFrecgen2In();
}

void Generador::cbFrecgen2In(){

     ovalorFrec->value(ofrecGen->value()*5.3687+ofrecGen2->value());
}



/*******************************************************************************
 * Generador::cb_amplitud: Callback del botón que selecciona la amplitud de la 
 *                         señal generada.
 * camplitud[]: Cadena de carácteres que contiene la amplitud configurada para
 *              mostrarla en el diplay de amplitud.
 * El valor del botón de configurar la amplitud de la señal se debe multiplicar 
 * por 51 para escalarlo a valores con el que se configura el hardware entre 0 y
 * FF hexadecimal y se almacena en una cadena de caracteres.
 * amplitudHexa[]: Cadena de caracteres que almacena el valor hexadecimal que
 *                  representa la amplitud configurada por el usuario.  
 * El dato de amplitud se encapsula en "trama_control[]" en la que se envía al 
 * hardware la amplitud configurada por el usuario.
*******************************************************************************/
void Generador::cb_amplitud(Fl_Widget* pboton, void *any){
     Generador* pgener=(Generador*)any;
     pgener->cb_amplitud_in();
}

void Generador::cb_amplitud_in(){
     char camplitud [10];
     sprintf(camplitud, "%.3g", oamplitud->value());
     odispAmplitud->value(camplitud);
     int ilong;
     itoa(oamplitud->value()*51,amplitudHexa,16);
     ilong = strlen(amplitudHexa);
     if (amplitudHexa[0] > 60){                                     //Para dejar caracteres numericos hexadecimales.            
           amplitudHexa[0]= amplitudHexa[0]-32;
     }
     if (amplitudHexa[1] > 60){
           amplitudHexa[1]= amplitudHexa[1]-32;
     }
     if (ilong>1){
        trama_control[4]= amplitudHexa[0];
        trama_control[5]= amplitudHexa[1];
     }
     else{
        trama_control[4]= '0';
        trama_control[5]= amplitudHexa[1];
     }
     trama_control[0]= 0x01;
     trama_control[1]= 'I';
     trama_control[2]= 'm';
     trama_control[3]= '2';
     trama_control[6]= 0x04;
     trama_control[7]= 0x06;
   //  Transmision();
  /*   if ( ~bhardware){
        fl_message("Error de hardware amp es %d", bhardware);
     }*/
}



/*******************************************************************************
 * Generador::cb_offset: Callback del botón que selecciona el nivel de offset de 
 *                       la señal generada.
 * coffset[]: Cadena de carácteres que contiene el valor de nivel de offset  
 *            configurado por el usuario para ser visualizado en el display de
 *            valor de offset.
 * El valor de offset se puede configurar entre -5V y 5V en la IGU pero para el 
 * hardware se debe enviar un dato hexadecimal entre 0xOO y 0xFF, por lo que hay
 * que multiplicar el dato del botón por 25.6 y sumarle 128 para luego convertir 
 * ese valor en hexadecimal y guardarlo en una cadena de caracteres.
 * offsetHexa[]: Cadena de caracteres que almacena el valor que se va a enviar
 *                al hardware del nivel de offset configurado por el usuario.
 * La cadena de caracteres offsetHexa[], se encapsula en la trama de protocolo
 * trama_control[] para configurar nivel de offset.
*******************************************************************************/
void Generador::cb_offset(Fl_Widget* pboton, void *any)
{
     Generador* pgener=(Generador*)any;
     pgener->cb_offset_in();
}

void Generador::cb_offset_in(){
     char coffset [10];
     sprintf(coffset, "%.2g", ooffset->value());                      //Almacenar en formato de dos decimales el valor configurado de nivel de offset          
     odispOffset->value(coffset);
     int ilong;                                               
     itoa(int((ooffset->value()*25.6)+128),offsetHexa,16);           //Escalar el valor configurado de offset entre 0x00 y 0xFF.
     ilong = strlen(offsetHexa);
     if (offsetHexa[0] > 60){
           offsetHexa[0]= offsetHexa[0]-32;
     }
     if (offsetHexa[1] > 60){
           offsetHexa[1]= offsetHexa[1]-32;
     }
     if (ilong>1){
        trama_control[4]= offsetHexa[0];
        trama_control[5]= offsetHexa[1];
     }
     else{
        trama_control[4]= '0';
        trama_control[5]= offsetHexa[1];
     }
     trama_control[0]= 0x01;
     trama_control[1]= 'I';
     trama_control[2]= 'n';
     trama_control[3]= '2';
     trama_control[6]= 0x04;
     trama_control[7]= 0x00;
 //    Transmision();
//     if (~bhardware)
  //      fl_message("Error de hardware");
}



/*******************************************************************************
 * Generador::cbFrec1: Callbacks del menú de escalas de frecuencias de la señal 
 *                      generada.  
 * El menú tiene 7 escalas de frecuencia que van desde 1Hz hasta 1 MHz.
 * Cuando se escoge alguna de las escalas, el botón de configurar frecuencia
 * se coloca en cero y se modifica el rango de dicho botón para la escala selec-
 * sionada en el menú. 
*******************************************************************************/

void Generador::cbFrec1(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Generador* pgener=(Generador*)pany;
     pgener->cbFrec1In(pselector);
}

void Generador::cbFrec1In(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     ofrecGen->range(0,1);
     ofrecGen->value(0);
     ofrecGen2->range(0,0.1);
     ofrecGen2->value(0);
     odispGen->value("0.0");
}

void Generador::cb_frec100(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Generador* pgener=(Generador*)pany;
     pgener->cb_frec100_in(pselector);
}

void Generador::cb_frec100_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     ofrecGen->range(0,100);
     ofrecGen->value(0);
     ofrecGen2->range(0,10);
     ofrecGen2->step(0.1);
     ofrecGen2->value(0);
     odispGen->value("0.0");
}


void Generador::cb_frec500(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Generador* pgener=(Generador*)pany;
     pgener->cb_frec500_in(pselector);
}

void Generador::cb_frec500_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     ofrecGen->range(0,500);
     ofrecGen->value(0);
     ofrecGen2->range(0,50);
     ofrecGen2->step(0.1);
     ofrecGen2->value(0);
     odispGen->value("0.0");
}


void Generador::cb_frec1k(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Generador* pgener=(Generador*)pany;
     pgener->cb_frec1k_in(pselector);
}

void Generador::cb_frec1k_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     ofrecGen->range(0,1000);
     ofrecGen->value(0);
     ofrecGen2->range(0,100);
     ofrecGen2->step(0.1);
     ofrecGen2->value(0);
     odispGen->value("0.0");
}

void Generador::cb_frec100k(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Generador* pgener=(Generador*)pany;
     pgener->cb_frec100k_in(pselector);
}

void Generador::cb_frec100k_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     ofrecGen->range(0,100000);
     ofrecGen->value(0);
     ofrecGen2->range(0,100);
     ofrecGen2->step(0.1);
     ofrecGen2->value(0);
     odispGen->value("0.0");
}

void Generador::cb_frec500k(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Generador* pgener=(Generador*)pany;
     pgener->cb_frec500k_in(pselector);
}

void Generador::cb_frec500k_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     ofrecGen->range(0,500000);
     ofrecGen->value(0);
     ofrecGen2->range(0,500);
     ofrecGen2->step(0.1);
     ofrecGen2->value(0);
     odispGen->value("0.0");
}

void Generador::cb_frec1m(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Generador* pgener=(Generador*)pany;
     pgener->cb_frec1m_in(pselector);
}

void Generador::cb_frec1m_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     ofrecGen->range(0,1000000);
     ofrecGen->value(0);
     ofrecGen2->range(0,1000);
     ofrecGen2->step(0.1);
     ofrecGen2->value(0);
     odispGen->value("0.0");
}



// class destructor
Generador::~Generador(){
	// insert your code here
}

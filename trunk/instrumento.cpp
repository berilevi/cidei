// Class automatically generated by Dev-C++ New Class wizard

#include "instrumento.h"  // Archivo de cabecera de clase
#include <stdio.h>
#include <FL/Fl_Ask.H>

// Constructor de la clase
Instrumento::Instrumento()
{

    inum_datos=0;
    strcpy(vid_pid, "vid_04d8&pid_000a");       // Product & Vendor ID
    strcpy(out_pipe, "\\MCHP_EP3");             // End Point de salida 
    strcpy(in_pipe, "\\MCHP_EP3");              // End Point de salida
    trama_control[0] = 0x01;                    // Valor de inicio de trama
    trama_control[5] = 0x04;                    // Final de trama del protocolo
    trama_control[6] = 0x00;                    // Fin de cadena que se va a transmitir
    strcpy(buf_mult,"0000");                    // Inicializar el bufer del multimetro.
    ch1_muestreado = 0;                         // Inicializar el estado del muestreo del canal 1 del osciloscopio
    ch2_muestreado = 0;                         // Inicializar el estado del muestreo del canal 2 del osciloscopio
    icont_muestreo_unico = 0;
    idato_osc_ch1 =0;
    idato_osc_ch2 =0;
}

// Destructor de clase
Instrumento::~Instrumento()
{
	// insert your code here
}


void Instrumento::activar(bool bx)
{
	bestado = bx;
}


void Instrumento::Sethardware(bool x)
{
	bhardware = x;
}


void Instrumento::Setarchivo(bool x)
{
	barchivo = x;
}


void Instrumento::Setnum_datos(int x)
{
	inum_datos = x;
}


/*
 * Esta función genera un archivo plano con los datos 
 * enviados por el hardware del instrumento.
 */
void Instrumento::archivar()
{
     FILE * log;
     log = fopen(cnombre,"w+");
     if (log != NULL) {
        fwrite(idatos,sizeof(int),inum_datos,log);
     }
     else {
          fl_alert("No se pudo abrir el archivo");     
     }          
}

/**
 * La función Transmision realiza la comunicación con el hardware a través de USB.
*/

void Instrumento::Transmision(){
   
   if (bestado){                     //Se ejecuta si el instrumento esta activo

      DWORD selection;               //Pipe para la transmision 
      fflush(stdin);
      selection = 0;

      myOutPipe = MPUSBOpen(selection,vid_pid,out_pipe,MP_WRITE,0);
      myInPipe = MPUSBOpen(selection,vid_pid,out_pipe,MP_READ,0);
      if(myOutPipe == INVALID_HANDLE_VALUE || myInPipe == INVALID_HANDLE_VALUE)
      {
        fl_message("Failed to open data pipes.");
        return;
      }

      DWORD RecvLength=190;        
      DWORD SentDataLength;
      
      //fl_message("envio al hw es: %s", trama_control);
    
      MPUSBWrite(myOutPipe,trama_control,10,&SentDataLength,1);
      fflush(stdin);
      
      MPUSBRead(myInPipe,receive_buf,190,&RecvLength,1);
      MPUSBRead(myInPipe,receive_buf,190,&RecvLength,1);
  
      Desencapsular(receive_buf);
             
      MPUSBClose(myOutPipe);
      MPUSBClose(myInPipe);
      myOutPipe = myInPipe = INVALID_HANDLE_VALUE;    
    
   }
   else {
        MPUSBClose(myOutPipe);
        MPUSBClose(myInPipe);
        myOutPipe = myInPipe = INVALID_HANDLE_VALUE;    
   }
}

/*
 * La función Encapsular organiza la trama que se envía
 * al hardware a través de USB.
*/
void Instrumento::Encapsular(char cnom, char coper, char clong, char cdato)
{
     trama_control[1] = cnom;           //Dispositivo de hardware 
     trama_control[2] = coper;          //Operacion que se va a realizar 
     trama_control[3] = clong;          //Longitud de datos que se van a enviar
     trama_control[4] = cdato;          //Dato que se va a configurar en el hardware
}

/*
 * La función GuardarBit guarda el bit como caracter en los
 * respectivos bufferes correspondientes a los canales del analizador
 * lógico. Se debe almacenar en los diferentes buffers de datos para
 * los canales declarados en instrumento.h
*/
void Instrumento::GuardarBit(int canal[], int posicion, bool bit)
{   
    if(bit == true) {
        canal[posicion] = 1;
    }
    else {
        canal[posicion] = 0;
    }
}

/**
 * La función Desencapsular organiza los datos enviados desde el hardware
 * a los instrumentos de software a través de USB.
*/
void Instrumento::Desencapsular(BYTE recibida [])
{
     // fl_message("trama recibida %s", recibida);
     int icont = 0;
     int itamano;
     itamano = int (recibida [3]);            //Tamano de la informacion enviada
     switch (recibida [1]){
            case 'A':
                 if (recibida [2] == '1'){                         //Osciloscopio canal 1
                   // fl_message("muestrear primer vector");
                   for (icont = 4; icont < 147; icont++){
                        buf_osc_ch1[icont-4]=int(recibida[icont]);
                        //fl_message("recibida en pos %d : %d", icont-4,buf_osc_ch1[icont-4]);
                    }
                 }
                 else if (recibida [2] == '2'){
                      for (icont = 4; icont < 147; icont++){
                          buf_osc_ch1[(icont-4)+143]=int(recibida[icont]);
                      }
                 }
                 else if (recibida [2] == '3'){
                      for (icont = 4; icont < 147; icont++){
                          buf_osc_ch1[(icont-4)+286]=int(recibida[icont]);
                      }
                 }
                 else if (recibida [2] == '4'){
                      for (icont = 4; icont < 147; icont++){
                          buf_osc_ch1[(icont-4)+429]=int(recibida[icont]);
                      }
                 }
                 break;
            case 'B':                         //Osciloscopio canal 2
                 switch (recibida [2]){
                        case '1':             //Primer vetor de datos
                             for (icont = 4; icont < (itamano+4); icont++){
                                 buf_osc_ch2[icont-4]=int(recibida[icont]);
                             }
                             break;
                        case '2':             //Segundo vector de datos
                             for (icont = 4; icont < (itamano+4); icont++){
                                 buf_osc_ch2[(icont-4)+143]=int(recibida[icont]);
                             }
                             break;
                        case '3':             //Tercer vector de datos
                             for (icont = 4; icont < (itamano+4); icont++){
                                 buf_osc_ch2[(icont-4)+286]=int(recibida[icont]);
                             }
                             break;
                        case '4':             //Cuarto vector de datos
                             for (icont = 4; icont < (itamano+4); icont++){
                                 buf_osc_ch2[(icont-4)+429]=int(recibida[icont]);
                             }
                             break;                    
                 }
                 break;
            case 'C':                         //Analizador lógico
                 /* TODO (JPP#1#): revizar lo que hizo ricardo para el analizador */
                 break;
            case 'D':                         //Voltimetro AC
                 strcpy(buf_mult,"0000");
                 for (icont=4;icont<(itamano+4);icont++){
                     buf_mult[icont-4]=receive_buf[icont];
                 }
                 if (itamano < 4){
                    buf_mult[itamano] = 0x00;
                 }
                 break;
            case 'E':                         //Voltimetro DC
                 strcpy(buf_mult,"0000");
                 for (icont=4;icont<(itamano+4);icont++){
                     buf_mult[icont-4]=receive_buf[icont];
                 }
                 if (itamano < 4){
                    buf_mult[itamano] = 0x00;
                 }
                 break;
            case 'F':                        //Amperimetro AC
                 strcpy(buf_mult,"0000");
                 for (icont=4;icont<(itamano+4);icont++){
                     buf_mult[icont-4]=receive_buf[icont];
                 }
                 if (itamano < 4){
                    buf_mult[itamano] = 0x00;
                 }
                 break;
            case 'G':                                      //Amperimetro DC
                 strcpy(buf_mult,"0000");
                 for (icont=4;icont<(itamano+4);icont++){
                     buf_mult[icont-4]=receive_buf[icont];
                 }
                 if (itamano < 4){
                    buf_mult[itamano] = 0x00;
                 }
                 break;
            case 'H':                                        //Ometro
                 strcpy(buf_mult,"0000");
                 for (icont=4;icont<(itamano+4);icont++){
                     buf_mult[icont-4]=receive_buf[icont];
                 }
                 if (itamano < 4){
                    buf_mult[itamano] = 0x00;
                 }
                 break;
            case 'I':                                         //Generador de señales
                 break;
            case 'J':                                         //Pruebas de conectividad de LIV
                 if (recibida [2]== 0x06){                    //ACK
                    Sethardware(true);
                 }
                 else if (recibida [2] == 0x15){              //NACK
                      fl_message("Error de Hardware nack");
                      Sethardware(0);
                 }
                 break;
            case 'K':                                          //Multimetro
                 break;
            case 'L':                                          //Osciloscopio
                 if (recibida [2] == 'p'){
                    if (recibida [4]== '1'){                   //Muestreo completo de señal en canal 1 del osciloscopio
                       ch1_muestreado = 1;         
                    }
                    else if(recibida [4]== '2'){
                        ch2_muestreado = 1; 
                    }
                 }
                 else if (recibida [2] == '1'){                //Muestreo de la señal dato por dato en canal 1
                      idato_osc_ch1=(recibida[4]);
                      icont_muestreo_unico++;
                 }
                 else if (recibida [2] == '2'){                //Muestreo de la señal dato por dato en canal 2
                      idato_osc_ch2=int(recibida[5]-'0');
                      icont_muestreo_unico++;
                 }
                 else if (recibida [2] == '3'){
                 }
                 break;
     ;}
}



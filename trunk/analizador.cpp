// Class automatically generated by Dev-C++ New Class wizard

#include "analizador.h" // class's header file

// class constructor
Analizador::Analizador() {                 
    strcpy(cvalor,"0.000");
    
    oana_on = new Fl_Light_Button(500,655,30,20,"ON");
    oana_on->labelsize(9);
    
    ogroup_ana = new Fl_Group(5,370,530,309,"");
    ogroup_ana->box(FL_ENGRAVED_FRAME);
    ogroup_ana->deactivate();  
   
    apantalla_ch1 = new Fl_Scope(8,373,380,32,"");  // Instancia de canal 1
    apantalla_ch2 = new Fl_Scope(8,407,380,30,"");  // Instancia de canal 2
    apantalla_ch3 = new Fl_Scope(8,439,380,30,"");  // Instancia de canal 3
    apantalla_ch4 = new Fl_Scope(8,471,380,30,"");  // Instancia de canal 4
    apantalla_ch5 = new Fl_Scope(8,503,380,30,"");  // Instancia de canal 5
    apantalla_ch6 = new Fl_Scope(8,535,380,30,"");  // Instancia de canal 6
    apantalla_ch7 = new Fl_Scope(8,567,380,30,"");  // Instancia de canal 7
    apantalla_ch8 = new Fl_Scope(8,599,380,30,"");  // Instancia de canal 8
    
    olog_ana = new Fl_Button(15,635,40,18,"Log");
    olog_ana->labelsize(10);
    
    ohelp_ana = new Fl_Button(15,656,40,18,"Help");
    ohelp_ana->labelsize(10);
    
    apantalla_ch2->TraceColour(FL_RED);
    apantalla_ch2->tracetype(FL_SCOPE_TRACE_LOOP);
    apantalla_ch2->redrawmode(FL_SCOPE_REDRAW_ALWAYS);
    apantalla_ch2->linetype(FL_SCOPE_LINE);
            
  //  ogroup_ana_botones = new Fl_Group(450,395,85,90,"");  // Agrupa los elementos del analizador
  //  ogroup_ana_botones->box(FL_ENGRAVED_FRAME); 
  //  ogroup_ana_botones->deactivate();
    
    atiempo_div = new Fl_Knob(425,400,70,70,"TIMER (MS)");
    av_posc = new Fl_Value_Output(435,485,50,20,"");     /* textbox para la posicion del canal */
    atiempo_div->color(147);
    atiempo_div->type(8);
    atiempo_div->labelsize(9);
    atiempo_div->scaleticks(10);
    atiempo_div->range(0,100);
    
    ogroup_ana->end();
    oana_on->callback(cb_ana_on, this);
}

// class destructor
Analizador::~Analizador() {

}
/**
 * Este callback es llamado cuando se inicializa el analizador
 * logico.
*/
void Analizador::cb_ana_on(Fl_Widget* pboton, void *pany) {
     Analizador* pana=(Analizador*)pany;
     pana->cb_ana_on_in();
}

/**
 * Esta es la funcion inline que es llamada desde el callback
 * cb_ana_on.
*/
void Analizador::cb_ana_on_in() {
      if(oana_on->value()== 1) {
        activar(1);
        ogroup_ana->activate();
 //       ogroup_ana_botones->activate();
        av_posc->value(1);
        apantalla_ch2->Add(410); /* no grafica */
        apantalla_ch2->redraw(); /* no vuelve a dibujar la pantalla */
        Fl::add_timeout(0.5, cb_timer_ana, this);
     }
     if(oana_on->value()== 0) {
        Fl::remove_timeout(cb_timer_ana, this);
        activar(0);
        ogroup_ana->deactivate();
        av_posc->value(0);
        ogroup_ana_botones->deactivate(); 
     }
}

/**
 * Este método es el callback del timer para realizar la solicitud 
 * de datos del analizador al hardware.  
*/
void Analizador::cb_timer_ana(void *pany) {
     Analizador* pana=(Analizador*)pany;
     pana->cb_timer_ana_in();
}

/**
 * Esta función acompaña la función cb_timer_ana
 * para realizar los llamados de callback del timer 
*/
void Analizador::cb_timer_ana_in() {
     Fl::repeat_timeout(0.9, cb_timer_ana, this);
     fl_message("el timer");
}
/**
 * Funcion para recorrer los buffers y graficar la informacion
*/
void Analizador::graficar_datos() {
/* TODO: hacer */
}

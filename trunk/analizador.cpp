// Class automatically generated by Dev-C++ New Class wizard

#include "analizador.h" // class's header file

//int isec_numdatos = 0;                                      
int iespera_trigger = 0;                                      //Contador de veces que debe esperar el instrumento antes de que ocurra el evento del trigger 
int inum_datos_grafica = 0;                                   //Contador del número máximo de datos representados en pantalla.                                   
//int icont = 0;                                                //Contador para llenar los arreglos de datos decimales y hexadecimal.
char  cbyte_anterior[] = "00000000";                          //Almacena el byte muestreado en t-1.
bool bconf_trigger = 0;                                       //Variable que indica si fue o no configurado el almacenamiento con trigger.
bool btermino_muestreo = 0;                                   //Variable que indica si terminó o no el muestreo.

/******************************************************************************
 * Analizador::Analizador: Constructor de la clase Analizador .
 * Se inicializan las variables y se realizan las instancias de los objetos que
 * hacen parte del instrumento y sus callbacks:
 * - Menú de frecuencias de muestreo.
 * - Perilla de deplazamiento horizontal de las gráficas.
 * - Botones de captura, trigger, ayuda, log, grilla y encendido del instrumento.
 * - Pantallas de grafica de los 8 canales.
 * - Cursor.
 * - Cuadro de texto donde se muestra la representación de los datos.
*******************************************************************************/
Analizador::Analizador() {                 
    
    idatapos = 0;                                                  //Inicializar la posición del arreglo pdataAnalizador[], donde se van a almacenar los datos.             
    inumMuestras = TAM_ALMACENADO;                                //Inicializar el contador de muestras almacenadas.
    igraf_datos = 20;                                              //Número de puntos graficados en pantalla por cada tiempo de muestreo.
    btimer_trigger = 0;
    btrigger = 0;
    bmuestreando = 0;
    inum_datos_grafica = 400/igraf_datos;                          //Número de muestras graficadas por pantalla.
     
    ogroup_ana = new Fl_Group(5,370,505,330,"");                   //Inicio del grupo de componentes del analizador
    ogroup_ana->box(FL_ENGRAVED_FRAME);
    ogroup_ana->box(FL_UP_BOX);
    ogroup_ana->deactivate(); 
     
    apantallaCh1 = new Fl_Scope(20,420,400,34,"");                // Canal 1
    apantallaCh2 = new Fl_Scope(20,452,400,34,"");                // Canal 2
    apantallaCh3 = new Fl_Scope(20,484,400,34,"");                // Canal 3
    apantallaCh4 = new Fl_Scope(20,516,400,34,"");                // Canal 4
    apantallaCh5 = new Fl_Scope(20,548,400,34,"");                // Canal 5
    apantallaCh6 = new Fl_Scope(20,580,400,34,"");                // Canal 6
    apantallaCh7 = new Fl_Scope(20,612,400,34,"");                // Canal 7
    apantallaCh8 = new Fl_Scope(20,644,400,34,"");                // Canal 8
    
    otextoMuestra = new Mensajes(20,417,400,20,"");               //Indicador del número de muestra 
    
    ogrilla = new grid(18,420,400,255,"");                         //Grilla del analizador
    ogrilla->bgrilla_analizador= 0;
    
    oscroll = new Fl_Scrollbar(10,680,420,10,"");                  //Scroll que posiciona el cursor. 
    oscroll->type(FL_HORIZONTAL);
    oscroll->range(0,19);
    oscroll->linesize(1);
    oscroll->step(1);
    oscroll->deactivate();
    
    olog_ana = new Fl_Button(340,375,40,15,"Log");                 //Botón que activa el alamacenamiento en archivo plano de texto.
    olog_ana->labelsize(10);
    
    ohelp_ana = new Fl_Button(340,390,40,15,"Help");               //Botón que lanza el archivo de ayuda del instrumento.
    ohelp_ana->labelsize(10);
    
    oayuda_ana = new Fl_Check_Button(385,382,20,16,"?");           //Check button que activa la ayuda de los botones del analizador.
    oayuda_ana->labelsize(12);
    
    ogrilla_on = new Fl_Light_Button(285,380,45,17,"Grilla");      //Botón que activa la grilla del instrumento.
    ogrilla_on->labelsize(10);
    
    // Configuraciones de las gráficas de los 8 canales
    
    apantallaCh1->TraceColour(FL_RED);
    apantallaCh1->tracetype(FL_SCOPE_TRACE_LOOP);
    apantallaCh1->redrawmode(FL_SCOPE_REDRAW_ALWAYS);
    apantallaCh1->linetype(FL_SCOPE_LINE);
    apantallaCh1->ScopeDataSize = 800;
    apantallaCh2->TraceColour(FL_RED);
    apantallaCh2->tracetype(FL_SCOPE_TRACE_LOOP);
    apantallaCh2->redrawmode(FL_SCOPE_REDRAW_ALWAYS);
    apantallaCh2->linetype(FL_SCOPE_LINE);
    apantallaCh2->ScopeDataSize = 800;
    apantallaCh3->TraceColour(FL_RED);
    apantallaCh3->tracetype(FL_SCOPE_TRACE_LOOP);
    apantallaCh3->redrawmode(FL_SCOPE_REDRAW_ALWAYS);
    apantallaCh3->linetype(FL_SCOPE_LINE);
    apantallaCh3->ScopeDataSize = 800;
    apantallaCh4->TraceColour(FL_RED);
    apantallaCh4->tracetype(FL_SCOPE_TRACE_LOOP);
    apantallaCh4->redrawmode(FL_SCOPE_REDRAW_ALWAYS);
    apantallaCh4->linetype(FL_SCOPE_LINE);
    apantallaCh4->ScopeDataSize = 800;
    apantallaCh5->TraceColour(FL_RED);
    apantallaCh5->tracetype(FL_SCOPE_TRACE_LOOP);
    apantallaCh5->redrawmode(FL_SCOPE_REDRAW_ALWAYS);
    apantallaCh5->linetype(FL_SCOPE_LINE);
    apantallaCh5->ScopeDataSize = 800;
    apantallaCh6->TraceColour(FL_RED);
    apantallaCh6->tracetype(FL_SCOPE_TRACE_LOOP);
    apantallaCh6->redrawmode(FL_SCOPE_REDRAW_ALWAYS);
    apantallaCh6->linetype(FL_SCOPE_LINE);
    apantallaCh6->ScopeDataSize = 800;
    apantallaCh7->TraceColour(FL_RED);
    apantallaCh7->tracetype(FL_SCOPE_TRACE_LOOP);
    apantallaCh7->redrawmode(FL_SCOPE_REDRAW_ALWAYS);
    apantallaCh7->linetype(FL_SCOPE_LINE);
    apantallaCh7->ScopeDataSize = 800;
    apantallaCh8->TraceColour(FL_RED);
    apantallaCh8->tracetype(FL_SCOPE_TRACE_LOOP);
    apantallaCh8->redrawmode(FL_SCOPE_REDRAW_ALWAYS);
    apantallaCh8->linetype(FL_SCOPE_LINE);
    apantallaCh8->ScopeDataSize = 800;
    
    // Habilitar las pantallas del analizador para gráficar
    // Esta habilitación se debe hacer porque se usa la misma clase para gráficar que se usa en el osciloscopio pero con 
    // algunas caracteristicas especiales que son propias del analizador. 
    
    apantallaCh1->banalizador = 1;
    apantallaCh2->banalizador = 1;
    apantallaCh3->banalizador = 1;
    apantallaCh4->banalizador = 1;
    apantallaCh5->banalizador = 1;
    apantallaCh6->banalizador = 1;
    apantallaCh7->banalizador = 1;
    apantallaCh8->banalizador = 1;
    
    ogroup_ana_botones = new Fl_Group(425,375,80,80,"");             // Agrupa los botones del analizador
    ogroup_ana_botones->box(FL_ENGRAVED_FRAME); 
    ogroup_ana_botones->deactivate();
           
    ofrec_muestreo = new Fl_Choice(430,400,70,20,"FrecMuestreo");    //Menú de las frecuencias de muestreo
    ofrec_muestreo->align(FL_ALIGN_TOP);
    ofrec_muestreo->labelsize(10);
    ofrec_muestreo->add("1",0,(Fl_Callback *)cbfrec1,this);
    ofrec_muestreo->add("2",0,(Fl_Callback *)cbfrec2,this);
    ofrec_muestreo->add("3",0,(Fl_Callback *)cbfrec3,this);
    ofrec_muestreo->add("4",0,(Fl_Callback *)cbfrec4,this);
    
    ogroup_ana_botones->end();                                       //Fin del grupo de los botones del analizador
    
    odes_horizontal = new Fl_Knob(430,460,70,70,"DespHor");          //Perilla para desplazar horizontalmente las gráficas
    odes_horizontal->color(147);
    odes_horizontal->type(8);
    odes_horizontal->scaleticks(0);
    odes_horizontal->labelsize(9);
    odes_horizontal->step(20);
   // odes_horizontal->range(0,400);
    odes_horizontal->range(0,1000);
    
        
    omuestrear_on = new Fl_Light_Button(430,560,70,30,"Capturar");   //Botón que inicia el muestreo y captura de las señales.
    omuestrear_on->labelsize(13);
    
    orep_dato = new Fl_Choice(430,620,70,20,"");                     //Menú de las representaciones numericas del dato señalado por el cursor
    orep_dato->add("Decimal");
    orep_dato->add("Binario");
    orep_dato->add("Hexadecimal");
    
    odato1 = new Fl_Output(430,645,70,25,"");                        //Cuadro de texto con la representación numerica del dato señalado por el cursor
    odato1->textsize(12);
    
        
    otrigger_on = new Fl_Light_Button(430,595,70,20,"Trigger");      //Botón que saca la ventana de configuración del trigger
    otrigger_on->labelsize(15);
    
    manualAnalizador = new Fl_Help_Dialog;
    manualAnalizador->load("help_analizador.html");                                                    
          
    ogroup_ana->end();                                               //Fin del grupo de los elementos del analizador
    
    obox_trigger = new Fl_Box(415,520,92,70,"");                     //Ventana de configuración del trigger
    obox_trigger->box(FL_UP_BOX);
    obox_trigger->hide();
    
    ogroup_trigger = new Fl_Group(415,520,92,70,"");                 //Grupo de elementos de configuración del trigger
    ogroup_trigger->hide();
    oflancosubida = new Fl_Button(420,530,20,20,"s");                //Botón de configuración de evento de flanco de subida para el trigger 
    oflancobajada = new Fl_Button(445,530,20,20,"b");                //Botón de configuración de evento de flanco de bajada para el trigger
    oselector = new Fl_Spinner(470,530,30,20,"");                    //selector del canal donde debe ocurrir el evento del flanco para empezar a muestrear
    oselector->range(1,8);
    ocerrar_trigger = new Fl_Button(460,565,40,16,"Cerrar");         //Botón para cerrar la ventana de configuración del trigger
    ocerrar_trigger->labelsize(9);
    
    ogroup_trigger->end();                                           //Fin del grupo de elementos de configuración del trigger
        
    obox_nombre = new Fl_Box(12,375,223,30,"ANALIZADOR LÓGICO");
    obox_nombre->box(FL_ENGRAVED_FRAME);
    obox_nombre->labelfont(FL_HELVETICA_BOLD);
    obox_nombre->labelsize(20);
    
    oana_on = new Fl_Light_Button(240,375,38,30,"ON");               //Botón para prender o apagar el instrumento
    oana_on->labelsize(9);
    
    ocursor = new Cursores(20,420,400,674);                          //Cursor de la pantalla del instrumento
    
    //Callbacks de los botones del instrumento
    
    oana_on->callback(cb_ana_on, this);
    omuestrear_on->callback(cb_muestrear,this);
    oscroll->callback(cb_scroll_cursor, this);
    otrigger_on->callback(cb_trigger_on,this);
    ocerrar_trigger->callback(cb_cerrar_trigger,this);
    oflancosubida->callback(cb_subida,this);
    oflancobajada->callback(cb_bajada,this);
    odes_horizontal->callback(cb_horizontal,this);
    ogrilla_on->callback(cb_grilla, this);
    ohelp_ana->callback(cb_help,this);
    olog_ana->callback(cb_log_ana, this);
}

/*******************************************************************************
* Analizador::~Analizador: Destructor de la clase.
*
*******************************************************************************/
Analizador::~Analizador() {
                                          
}


/*******************************************************************************
 * Analizador::cb_ana_on: Callback del botón que prende/apaga el Analizador
 *                        Lógico.
 * Al prender el instrumento se inicia con las siguientes configuraciones por
 * defecto:
 * - Tipo de representación de los datos señalados con el cursor: Binario
 * - Frecuencia de muestreo: La más baja.
*******************************************************************************/
void Analizador::cb_ana_on(Fl_Widget* pboton, void *pany) {
     Analizador* pana=(Analizador*)pany;
     pana->cb_ana_on_in();
}

void Analizador::cb_ana_on_in() {
     if(oana_on->value()== 1) {
        activar(1);
        Encapsular('C','a','1','0',0x00,0x00);             //Trama de encendido del instrumento.
        Transmision();
        if (bhardware){
           ogroup_ana->activate();
           ogroup_ana_botones->activate();
           //isec_numdatos = 0;
           orep_dato->value(1);                            //Representación Binaria
           oselector->value(1);                            //Frecuencia de muestreo más baja.
        }
        else {
             fl_message("Error de hardware");
        }
     }
     if(oana_on->value()== 0) {
        Fl::remove_timeout(cb_timer_ana, this);
        activar(0);
        ogroup_ana->deactivate();
        apantallaCh1->banalizador = 0;
        apantallaCh2->banalizador = 0;
        apantallaCh3->banalizador = 0;
        apantallaCh4->banalizador = 0;
        apantallaCh5->banalizador = 0;
        apantallaCh6->banalizador = 0;
        apantallaCh7->banalizador = 0;
        apantallaCh8->banalizador = 0;
        ocursor->iposx = 0;
        ogroup_ana_botones->deactivate();
        oflancosubida->value(0);
        oflancosubida->box(FL_UP_BOX); 
        oflancobajada->value(0);
        oflancobajada->box(FL_UP_BOX);
     }
}


/*******************************************************************************
 * Analizador::cb_grilla: Callback del botón para activar o desactivar la grilla 
 *                        en la pantalla del analizador.
 * Coloca una grilla en la pantalla del analizador, para ayudar al usuario a 
 * identificar el inicio y final de cada dato muestreado.
 * Como se usa la misma clase grid que se usa en el oscilocopio, se debe modifi-
 * car el atributo bgrilla_analizador para que se grafique la grilla de analiza-
 * dor y no la de osciloscopio: "ogrilla->bgrilla_analizador= 1";
*******************************************************************************/
void Analizador::cb_grilla(Fl_Widget* pboton, void *pany){
     Analizador* pana=(Analizador*)pany;
     pana->cb_grilla_in();
}

void Analizador::cb_grilla_in(){
     if (ogrilla_on->value()==1){
         ogrilla->bgrilla_analizador= 1;           //Activar en el objeto grilla, la gráfica de la grilla para analizador.
         ogrilla->bgrid = 1;
     }
     else{
        ogrilla->bgrilla_analizador= 0;
        ogrilla->bgrid = 0;
     }
     ogrilla->redraw();
     ogroup_ana->redraw();
     obox_nombre->redraw();
     oana_on->redraw();
}


/*******************************************************************************
 * Analizador::cb_trigger_on: Callback para seleccionar la configuración del 
 *                            sistema de trigger del analizador lógico.
 * Al presionar el botón, aparece la ventana de configuración del trigger con 
 * la configuración por defecto:
 * Tipo de flanco: Subida.
 * Canal donde debe ocurrir el evento: Canal 1.
 * En esta ventana se puede modificar la configuración anterior.
 * Si el botón se presiona para apagarlo, se desactivan la opciones de trigger. 
*******************************************************************************/
void Analizador::cb_trigger_on(Fl_Widget* pboton, void *pany) {
     Analizador* pana=(Analizador*)pany;
     pana->cb_trigger_on_in();
}

void Analizador::cb_trigger_on_in() {
     if(otrigger_on->value()== 1) {
        obox_trigger->show();
        ogroup_trigger->show();
        bconf_trigger = 1;                                    //Modificada la variable que indica que se configuró un evento (trigger) para iniciar el muestreo
        oflancosubida->value(1);                              //Valor por defecto de flanco de subida.
        oflancosubida->box(FL_DOWN_BOX);
     }
     else{
         bconf_trigger = 0; 
     }
}


/*******************************************************************************
 * Analizador::cb_cerrar_trigger: Callback del botón para cerrar el panel de 
 *                                configuración del sistema de trigger.
 * Esconde la ventana de configuracion del sistema de trigger del instrumento.
*******************************************************************************/
void Analizador::cb_cerrar_trigger(Fl_Widget* pboton, void *pany) {
     Analizador* pana=(Analizador*)pany;
     pana->cb_cerrar_trigger_in();
}

void Analizador::cb_cerrar_trigger_in() {
     obox_trigger->hide();
     ogroup_trigger->hide();
}



/*******************************************************************************
 * Analizador::cb_muestrear: Callback del botón que habilita el muestreo en el 
 *                           analizador.
 * Al presionar el botón se inicia el timer que solicita los datos al hardware
 * de los 8 canales. 
*******************************************************************************/
void Analizador::cb_muestrear(Fl_Widget* pboton, void *pany) {
     Analizador* pana=(Analizador*)pany;
     pana->cb_muestrear_in();
}

void Analizador::cb_muestrear_in() {
     if(omuestrear_on->value()== 1) {
       omuestrear_on->value(0);
       btermino_muestreo = 0;
       omuestrear_on->box(FL_DOWN_BOX);
       ogrilla->redraw();
       Fl::add_timeout(0.1, cb_timer_ana, this);
     }  
}


/*******************************************************************************
 * Analizador::cb_subida: Callback del botón que activar el trigger por flanco 
 *                        de subida.  
 * Al presionar este botón se configura que el sistema espere un evento de flan-
 * co de subida en el canal seleccionado.
 * Este botón es excluyente del botón de configuración de trigger por flanco de
 * bajada.
*******************************************************************************/
void Analizador::cb_subida(Fl_Widget* pboton, void *pany) {
     Analizador* pana=(Analizador*)pany;
     pana->cb_subida_in();
}

void Analizador::cb_subida_in() {
      if (oflancosubida->value()== 0){
         oflancobajada->box(FL_UP_BOX);                      
         oflancobajada->value(0);            //Si se escoge flanco de subida, se debe desactivar el botón de flanco de bajada 
         oflancosubida->value(1);
         oflancosubida->box(FL_DOWN_BOX);
      }
}

/*******************************************************************************
 * Analizador::cb_bajada: Callback del botón que activar el trigger por flanco 
 *                        de bajada.  
 * Al presionar este botón se configura que el sistema espere un evento de flan-
 * co de bajada en el canal seleccionado.
 * Este botón es excluyente del botón de configuración de trigger por flanco de
 * subida.
*******************************************************************************/
void Analizador::cb_bajada(Fl_Widget* pboton, void *pany) {
     Analizador* pana=(Analizador*)pany;
     pana->cb_bajada_in();
}

void Analizador::cb_bajada_in() {
     if (oflancobajada->value()== 0){
         oflancosubida->box(FL_UP_BOX);                      
         oflancosubida->value(0);                   //Si se escoge flanco de bajada, se debe desactivar el botón de flanco de subida
         oflancobajada->value(1);
         oflancobajada->box(FL_DOWN_BOX);
      }
}


/*******************************************************************************
 * Analizador::cb_scroll_cursor: Callback del scroll que modifica la posición 
 *                               del cursor en la pantalla del Analizador.
 * ocursor->iposx: Posición de la pantalla donde se debe dibujar el cursor:
 *                 El cursor se posiciona en la mitad de cada dato muestreado
 *                 graficado en la pantalla.
 * El dato donde se posiciona el cursor es representado en el cuadro de texto
 * dependiendo el tipo de numeración escogido por el usuario para su representa-
 * cion: Binaria, Decimal ó Hexadecimal.
 * orep_dato->value(): Opción seleccionada por el usuario para ver la represen-
 *                     tación del dato señalado por el cursor.
 *                     - 0 : Si el valor es cero, el usuario ha seleccionado ver
 *                           el dato señalado por el cursor en representación
 *                           Decimal.
 *                     - 1 : Si el valor es uno, el usuario ha seleccionado ver
 *                           el dato señalado por el cursor en representación
 *                           binaria; este es el valor por defecto.
 *                     - 2 : Si el valor es dos, el usuario ha seleccionado ver
 *                           el dato señalado por el cursor en representación
 *                           Hexadecimal.
 * - Para mostrar el dato señalado en representación binaria, se coloca en el 
 *   display la posición del arreglo pdataAnalizador[], que el cursor está 
 *   señalando.
 * - Para mostrar el dato señalado en representación Decimal, se envía como 
 *   parámetro al método bianrioadecimal(char [8]), la cadena de carácteres de 
 *   la posición señalada por el cursor, donde se convierte en un dato decimal 
 *   que es retornado y almacenado en la variable idecimal; El valor retornado 
 *   se almacena en una cadena de carácteres cdatoDecimal[6], como dato decimal
 *   para luego ser colocada en el display.
 * - Para mostrar el dato señalado en representación Hexadecimal, se envía como 
 *   parámetro al método bianrioadecimal(char [8]), la cadena de carácteres de 
 *   la posición señalada por el cursor, donde se convierte en un dato decimal 
 *   que es retornado y almacenado en la variable ihexa; El valor retornado 
 *   se almacena en una cadena de carácteres cdatoHexa[6], como dato hexadecimal
 *   para luego ser colocada en el display.   
*******************************************************************************/
void Analizador::cb_scroll_cursor(Fl_Widget* pboton, void *pany) {
     Analizador* pana=(Analizador*)pany;
     pana->cb_scroll_cursor_in();
}

void Analizador::cb_scroll_cursor_in() { 
    
    char cdatoDecimal[6];
    char cdatoHexa[6]; 
     
    ocursor->iposx = ((inum_datos_grafica/2)+(inum_datos_grafica*oscroll->value())-2);  //Cálculo de la posición del cursor
    
    ocursor->redraw();                                   // Redibujar el cursor                              
    
    //Redibujar las gráficas en todos los canales
    
    apantallaCh1->redraw();
    apantallaCh2->redraw();
    apantallaCh3->redraw();
    apantallaCh4->redraw();
    apantallaCh5->redraw();
    apantallaCh6->redraw();
    apantallaCh7->redraw();
    apantallaCh8->redraw();
    
    ogrilla->redraw();                                   // Redibujar la grilla                               
    
    // Para conocer la posición en el arreglo del dato que el cursor está señalando.
    
    int ipos = int((odes_horizontal->value()/20));                                      
    if (orep_dato->value()==1){                                                         //Si el tipo de representación seleccionada es tipo binario
       odato1->value(pdataAnalizador[oscroll->value()+ipos]);                          //Mostrar el dato seleccionado con el cursor en el cuadro de texto.
    }    
    else if (orep_dato->value()==0){
         int idecimal = bianrioadecimal(pdataAnalizador[oscroll->value()+ipos]);       //Llamada al método para convertirlo en dato decimal se envía como parametro la cadena de datos.
         itoa(idecimal,cdatoDecimal,10);                                                //El dato decimal se convierte a cadena de caracteres decimales
         odato1->value(cdatoDecimal);                                                   //Colocar el dato decimal en el display.
    }
    else if (orep_dato->value()==2){
         int ihexa = bianrioadecimal(pdataAnalizador[oscroll->value()+ipos]);          //Llamada al método para convertir a dato decimal.
         itoa(ihexa,cdatoHexa,16);                                                      //El dato decimal se convierte en cadena de caracteres hexadecimales.
         fl_message("pos es %d",oscroll->value()+ipos);
         odato1->value(cdatoHexa);                                                      //Colocar el dato hexadecimal en el display.
    }
      
}

/*******************************************************************************
 * Analizador::bianrioadecimal: Método para convertir el dato señalado con el 
 *                              cursor a un valor entero para visualizarlo.   
 * Retorna el valor entero de la cadena de carácteres binarios que llega como  
 * parámetro.
 * char cbinario[8]: Cadena de carácteres donde está almacenada la muestra en
 *                   datos binarios que el cursor está señalando.
 * Para convertir la cadena de carácteres binarios a un dato decimal, se recorre
 * la cadena cbinario[] y en cada ocurrencia de un caracter '1', se realiza una
 * operación de potencia  (2^x) donde x (el exponente) está relacionado con la 
 * posición del caracter '1', dentro del arreglo. 
*******************************************************************************/
int Analizador::bianrioadecimal(char cbinario[8]) {
     int idatoDecimal=0;
     for(int i = 7; i >= 0; i--){
        if (cbinario[i]=='1'){
           idatoDecimal= idatoDecimal+(pow(2,(7-i)));      
        }
     }
     return idatoDecimal;
}



/*******************************************************************************
 * Analizador::cb_timer_ana: Callback del timer para realizar la solicitud 
 *                           de datos del analizador al hardware.
 * En cada ocurrencia del timer se encapsula una trama de solicitud de datos de
 * Analizador.
 * separar_canales(): Método donde se separan los datos adquiridos por cada 
 *                    canal para convertirlos en cadenas de datos binarios y al-
 *                    macenarlos en un arreglo.
 * El llamado al timer se repite de acuerdo a la frecuencia de muestreo que el
 * usuario configure.    
*******************************************************************************/
void Analizador::cb_timer_ana(void *pany) {
     Analizador* pana=(Analizador*)pany;
     pana->cb_timer_ana_in();
}

void Analizador::cb_timer_ana_in() {
     Encapsular('C','p','1','0',0x00,0x00);                                     //Trama de solicitud de datos de analizador
     Transmision();
     separar_canales();
     if (btermino_muestreo == 0) {
        Fl::repeat_timeout(0.01, cb_timer_ana, this);                           //Repetición del llamado al timer.
     }
}


/*******************************************************************************
 * Analizador::separar_canales: Método donde se separan los datos adquiridos por 
 *                              cada canal para convertirlos en cadenas de datos 
 *                              binarios y almacenarlos en un arreglo.
 * buf_analizador[2]: Cadena de caracteres que almacena el dato recibido del 
 *                   hardware del muestreo del bus de 8 bits. Este dato llega
 *                   convertido en carácteres hexadecimales entre 0x00 y 0xFF.
 * ilong: Variable para almacenar el número de carácteres '1's o '0's que repre-
 *        sentan en binario cada uno de los caracteres hexadecimales que envía
 *        el hardware; este dato es útil para poder guardar los datos en cadenas
 *        de carácteres de 8 posiciones.
 * ipos_msb: Variable donde se almacena el carácter hexadecimal más significati-
 *           vo que llega del hardware.
 * ipos_lsb: Variable donde se almacena el carácter hexadecimal menos signifi-
 *           cativo que llega del hardware.
 * cbyte_actual[]: Cadena de carácteres donde se almacena temporalmente el dato
 *                 recibido convertido en carácteres de digitos binarios.
 * cbyte_anterior[]: Cadena de carácteres donde se almacena temporalmente el dato
 *                 recibido convertido en carácteres de digitos binarios para
 *                 compararlo con el próximo dato que llega y hacer el análisis
 *                 del cambio de estado en caso de estar configurado el muestreo
 *                 con trigger. 
 * El almacenamiento de los datos se puede realizar de 2 modos:
 * - Modo simple: El almacenamiento se realiza incondicionalmente al presionar
 *                el botón de muestrar; en este modo se almacena hasta el máxi-
 *                mo numero de datos establecido y cuando se haya terminado se
 *                envían los datos a gráficar.
 * - Modo con trigger: El almacenamiento empieza cuando se cumpla el evento con-
 *                     figurado en la ventana de trigger; si el evento no se 
 *                     cumple despues de "ESPERA_TRIGGER" muestreos, no se  
 *                     almacenan datos. al finalizar el almacenamiento, se 
 *                     envian los datos para ser graficados.
 * ESPERA_TRIGGER: Constante de número máximo de muestreos esperados para que
 *                 ocurra el evento configurado de disparo. 
 * trigger(): Método que analiza si ocurrio o no el evento de trigger configura-
 *            do por el usuario; retorna un valor booleano (True/False).
 * almacenar(): Método para almacenar los datos recibidos, en el arreglo para
 *              despues ser graficados.                  
*******************************************************************************/
void Analizador::separar_canales() {
     
     int ilong;
     int ipos_msb;
     int ipos_lsb;
     
     // Convertir los carácteres que envía el hardware a numeros enteros
     
     if (buf_analizador[0] > 64){                        //Si el carácter es un dato hexadecimal mayor que '9': 'A', 'B', 'C'.....
        ipos_msb = int(buf_analizador[0]-55);
     }
     else{                                               //Si el carácter es un dato hexadecimal entro '0' y '9'.
         ipos_msb = int(buf_analizador[0]-48); 
     }
     if (buf_analizador[1] > 64){                        //Si es un dato hexadecimal mayor que '9': 'A', 'B', 'C'.....
        ipos_lsb = int(buf_analizador[1]-55);
     }
     else{                                               //Si es un dato hexadecimal entro '0' y '9'.
         ipos_lsb = int(buf_analizador[1]-48); 
     }
          
     // Guardar el número hexadecimal más significativo convertido a binario en una cadena de caracteres  
     itoa(ipos_msb,recibido_msb,2);
     ilong = strlen(recibido_msb);                                 
     
     //El dato se debe almacenar en una cadena de 4 carácteres     
     for (int i= 4; i > 0; i-- ){
         if (ilong > 0){
            recibido_msb2[i-1] = recibido_msb[ilong-1];
         }
         else {
              recibido_msb2[i-1] = '0';
         }
         ilong --;
     }
     
     // Guardar el número hexadecimal menos significativo convertido a binario en una cadena de caracteres
     itoa(ipos_lsb,recibido_lsb,2);
     ilong = strlen(recibido_lsb);
     
     //El dato se debe almacenar en una cadena de 4 carácteres
     for (int i= 4; i > 0; i-- ){
         if (ilong > 0){
            recibido_lsb2[i-1] = recibido_lsb[ilong-1]; 
         }
         else {
              recibido_lsb2[i-1] = '0';
         }
         ilong --;
     }
     
     //Alamcenar el dato recibido completo en un arreglo de carácteres de 8 posiciones.
     cbyte_actual[0]= recibido_msb2[0];
     cbyte_actual[1]= recibido_msb2[1];
     cbyte_actual[2]= recibido_msb2[2];
     cbyte_actual[3]= recibido_msb2[3];
     cbyte_actual[4]= recibido_lsb2[0];
     cbyte_actual[5]= recibido_lsb2[1];
     cbyte_actual[6]= recibido_lsb2[2];
     cbyte_actual[7]= recibido_lsb2[3];  
     
     
     // Control de flujo del programa para el almacenamiento de datos  en caso de 
     // ser configurado o no el muestreo con condiciones de trigger.
     
     if (bmuestreando == 0){                                        //Si aún no se ha comenzado a almacenar los datos muestrados                            
         if (bconf_trigger == 1){                                   //Si el usuario configuró el sistema de trigger
             btrigger = trigger();                                  
             if (btrigger == 0){                                    //Si no ha ocurrido el evento de disparo configurado.
                if (iespera_trigger < ESPERA_TRIGGER){              //Si no se ha cumplido la espera para que ocurra el trigger.
                   iespera_trigger++; 
                   goto salir;                                      //Salir de la rutina.      
                }
                else if (iespera_trigger == ESPERA_TRIGGER){        //Si se cumplio la espera del trigger y no ocurrio el evento
                     iespera_trigger = 0;
                     Fl::remove_timeout(cb_timer_ana, this);        //Cancelar el timer de solicitud de muestras
                     btermino_muestreo = 1;
                     omuestrear_on->value(1);
                     omuestrear_on->box(FL_UP_BOX);
                     oscroll->activate();
                     idatapos = 0;
                     bmuestreando = 0;
                     btrigger = 0;
                     btimer_trigger = 0;
                     omuestrear_on->value(0);
                     goto salir;                                    //Salir de la rutina
                }
             }
             else{                                                  //Si ocurrio el evento de trigger         
                  bmuestreando = 1;
                  iespera_trigger = 1;
             }
         }             
     }
     
     almacenar();                                                   //Almacenar el dato que envío el hardware     
 salir:
     strcpy(cbyte_anterior,cbyte_actual);                           //Almacenar temporalmente el dato recibido para compararlo con el siguiente.
}


/*******************************************************************************
 * Analizador::trigger: Método para determinar si ocurrio el evento que dispara 
 *                      el almacenamiento de datos; retorna un valor booleano
 *                      (True/False).
 * El análisis se realiza comparando los arreglos cbyte_actual[] con 
 * cbyte_anterior[], en la posición seleccionada en la ventana de trigger.
 * Se reviza el cambio de valor de la posición del arreglo que corresponde al 
 * canal seleccionado. 
*******************************************************************************/

bool Analizador::trigger() {
    if (oflancosubida->value()== 1){                                            //Si está comfigurado el cambio de nivel de 0 a 1
       if (cbyte_actual[int(oselector->value())-1] > cbyte_anterior [int(oselector->value())-1]){   //Comparacion del cambio de nivel
          btrigger=1;               //Se cumplio el evento
          iespera_trigger = 1;                                                                     
          btimer_trigger = 0;
       }
       else {
            btrigger=0;           //No se cumplio el evento                                              
       }
    }
    else{                                                                       //Si está comfigurado el cambio de nivel de 1 a 0
         if (cbyte_actual[int(oselector->value())] < cbyte_anterior [int(oselector->value())]){
            btrigger=1;            //Se cumplio el evento
            iespera_trigger = 1;
            btimer_trigger = 0;
         }
         else {
              btrigger=0;         //No se cumplio el evento 
         }
    }
    return btrigger;             
}


/*******************************************************************************
 * Analizador::almacenar: Método para almacenar los datos muestreados enviados
 *                        por el hardware en un arreglo para posteriormente ser
 *                        graficados.
 * Mientras el arreglo no se haya llenado, se almacena en al arreglo el dato que
 * envía el hardware; cuando el arreglo se  haya completado se termina el timer
 * de solicitud de datos y se hace un llamado a la función para gráficar los 
 * datos.
 * graficar_datos(): Método en el que se recorre el arreglo almacenado y se en-
 *                   vían los datos para ser graficados.
*******************************************************************************/
void Analizador::almacenar() {
     if (idatapos > inumMuestras-1) {                         //Si ya se completó el arreglo                 
           Fl::remove_timeout(cb_timer_ana, this);             //Detener el timer de solicitud de datos
           btermino_muestreo = 1;
           omuestrear_on->value(1);
           omuestrear_on->box(FL_UP_BOX);
           oscroll->activate();                                //Activar el cursor para seleccionar dato
           idatapos = 0;
           bmuestreando = 0;
           btrigger = 0;
           btimer_trigger = 0;
           omuestrear_on->value(0);
           graficar_datos();                                   //Graficar los datos almacenados.
     }
     
     else{
          strcpy(pdataAnalizador [idatapos], cbyte_actual);     //Almacenar el dato en el arreglo
          idatapos++;
          bmuestreando = 1;
          ocursor->redraw();                                     //Redibujar el cursor 
     }
}


/*******************************************************************************
 * Analizador::cb_horizontal: Callback del botón de desplazameinto horizontal
 *                            de las gráficas.
 * Como por pantalla solo se pueden representar 20 muestras y el muestreo toma
 * un número mayor, con este botón se desplazan las gráficas horizontalmente 
 * a la izquierda para poder observar los demas datos muestreados.
 * El indicador del número de la muestra tambien se va desplazando al mismo
 * tiempo que las gráficas.
 * El valor presentado en el display del dato, tambien debe ser actualizado con
 * la posición de la muestra que está indicando el cursor.    
*******************************************************************************/
void Analizador::cb_horizontal(Fl_Widget* pboton, void *pany) {
     Analizador* pana=(Analizador*)pany;
     pana->cb_horizontal_in();
}

void Analizador::cb_horizontal_in() {
    otextoMuestra->inum_inicial = int(odes_horizontal->value()/20);   //Desplazar al mismo tiempo que las graficas el número de muestra
    
    //Cambiar el dato con el que se inicia las gráficas a la izquierda de la pantalla del analizador
    apantallaCh1->ipos_x = int(odes_horizontal->value());
    apantallaCh1->redraw();
    apantallaCh2->ipos_x = int(odes_horizontal->value());
    apantallaCh2->redraw();
    apantallaCh3->ipos_x = int(odes_horizontal->value());
    apantallaCh3->redraw();
    apantallaCh4->ipos_x = int(odes_horizontal->value());
    apantallaCh4->redraw();
    apantallaCh5->ipos_x = int(odes_horizontal->value());
    apantallaCh5->redraw();
    apantallaCh6->ipos_x = int(odes_horizontal->value());
    apantallaCh6->redraw();
    apantallaCh7->ipos_x = int(odes_horizontal->value());
    apantallaCh7->redraw();
    apantallaCh8->ipos_x = int(odes_horizontal->value());
    apantallaCh8->redraw();
    
    //Actualizar el dato que queda señalado con el cursor y que se muestra en el display
    int ipos = int((odes_horizontal->value()/20));
    odato1->value(pdataAnalizador[oscroll->value()+ipos]);
    
    //Redibujar todos los objetos.
    ogrilla->redraw();
    ocursor->redraw();
    otextoMuestra->redraw();
    ogroup_ana->redraw();
    obox_nombre->redraw();
    oana_on->redraw();
}



/*******************************************************************************
 * Analizador::graficar_datos: Método para recorrer el arreglo donde están alma-
 *                             cenados los datos muestrados que envío el hardwa-
 *                             re.
 * Para gráficar los datos, se recorre el arreglo que los contiene y se analiza 
 * el caracter que contiene cada posición:
 * si es '1': se envía 50000 como dato para gráficar.
 * si es '0': se envía 10000 como dato para gráficar.
 * El dato se gráfica por pixels y se tiene que enviar un número de veces que   
 * depende de la cantidad de datos que se quieran visualizar en la pantalla o el
 * tiempo de bit que se quiera representar en pantalla.
 * Como la pantalla tiene 400 pixels de ancho y se quieren representar 20 datos 
 * por pantalla, se debe repetir el dato para graficar 20 veces (igraf_datos).
 * El proceso se debe hacer para los 8 canales. 
*******************************************************************************/
void Analizador::graficar_datos() {
     
     
     for (int o=0; o<inumMuestras; o++) {               // Ciclo para recorrer el arreglo que contiene las cadenas de caracteres con las muestras
             
         //Canal 1
         if (pdataAnalizador[o][0]=='1'){               //Si el dato es '1'.
            for (int i=0; i<igraf_datos;i++){            //Ciclo para crear el tiempo de bit graficado; se hace enviando un numero constante de veces el mismo dato.        
                apantallaCh1->Add(50000);
            }
         }
         else if (pdataAnalizador[o][0]=='0'){             
              for (int i=0; i<igraf_datos;i++){ 
                  apantallaCh1->Add(10000);
              }
         }
         //Canal 2
         if (pdataAnalizador[o][1]=='1'){                
            for (int i=0; i<igraf_datos;i++){ 
                apantallaCh2->Add(50000);
            }
         }
         else if (pdataAnalizador[o][1]=='0'){              
              for (int i=0; i<igraf_datos;i++){ 
                  apantallaCh2->Add(10000);
              }
         }
         //Canal 3
         if (pdataAnalizador[o][2]=='1'){                 
            for (int i=0; i<igraf_datos;i++){ 
                apantallaCh3->Add(50000);
            }
         }
         else if (pdataAnalizador[o][2]=='0'){              
              for (int i=0; i<igraf_datos;i++){ 
                  apantallaCh3->Add(10000);
              }
         }
         //Canal 4
         if (pdataAnalizador[o][3]=='1'){                 
            for (int i=0; i<igraf_datos;i++){ 
                apantallaCh4->Add(50000);
            }
         }
         else if (pdataAnalizador[o][3]=='0'){                 
              for (int i=0; i<igraf_datos;i++){ 
                  apantallaCh4->Add(10000);
              }
         }
         //Canal 5
         if (pdataAnalizador[o][4]=='1'){            
            for (int i=0; i<igraf_datos;i++){ 
                apantallaCh5->Add(50000);
            }
         }
         else if (pdataAnalizador[o][4]=='0'){               
              for (int i=0; i<igraf_datos;i++){ 
                  apantallaCh5->Add(10000);
              }
         }
         //Canal 6
         if (pdataAnalizador[o][5]=='1'){                
            for (int i=0; i<igraf_datos;i++){ 
                apantallaCh6->Add(50000);
            }
         }
         else if (pdataAnalizador[o][5]=='0'){                 
              for (int i=0; i<igraf_datos;i++){ 
                  apantallaCh6->Add(10000);
              }
         }
         //Canal 7
         if (pdataAnalizador[o][6]=='1'){                
            for (int i=0; i<igraf_datos;i++){ 
                apantallaCh7->Add(50000);
            }
         }
         else if (pdataAnalizador[o][6]=='0'){                
              for (int i=0; i<igraf_datos;i++){ 
                  apantallaCh7->Add(10000);
              }
         }
         //Canal 8
         if (pdataAnalizador[o][7]=='1'){                  
            for (int i=0; i<igraf_datos;i++){ 
                apantallaCh8->Add(50000);
            }
         }
         else if (pdataAnalizador[o][7]=='0'){             
              for (int i=0; i<igraf_datos;i++){ 
                  apantallaCh8->Add(10000);
              }
         }
         ocursor->redraw();                                 //Redibujar el cursor
     }
}


/*******************************************************************************
 * Analizador::cb_help: Callback del botón que lanza la ayuda del uso del
 *                      instrumento. 
 * El Callaback consta de la función static e inline cb_help y cb_help_in.
 * Se despliega una ventana de ayuda con un archivo en html con la guía de
 * usuario del instrumento.
*******************************************************************************/
void Analizador::cb_help(Fl_Widget* pboton, void *pany){
     Analizador* pana=(Analizador*)pany;
     pana->cb_help_in();
}

void Analizador::cb_help_in(){
      manualAnalizador->show();
}


/*******************************************************************************
 * Analizador::cb_log_ana: Callback del botón que activa el almacenamiento en 
 *                         archivos planos de texto de los datos capturados 
 *                         para el analizador lógico.  
 * El Callaback consta de la función static e inline cb_log_ana y cb_log_ana_in.
 * analizador.txt: Archivo plano de texto que contiene los datos muestreados y 
 *                 almacenados en el arreglo pdataAnalizador[]. 
*******************************************************************************/
void Analizador::cb_log_ana(Fl_Widget* pboton, void *pany){
     Analizador* pana=(Analizador*)pany;
     pana->cb_log_ana_in();
}

void Analizador::cb_log_ana_in(){
    ofstream log("analizador.txt");
    for (int o=0; o<inumMuestras; o++) {
        log << pdataAnalizador[o] << endl;
    }
	log.close(); 
}

/*******************************************************************************
* Analizador::cbfrec1: Callback para la primera frecuencia de muestreo seleccio-
*                      nada en el menú.
*
*******************************************************************************/

void Analizador::cbfrec1(Fl_Widget* pmenu, void *pany){
     Analizador* pana = (Analizador*)pany;
     pana->cbfrec1_in();
}

void Analizador::cbfrec1_in(){
     
}

/*******************************************************************************
* Analizador::cbfrec1: Callback para la segunda frecuencia de muestreo seleccio-
*                      nada en el menú.
*
*******************************************************************************/

void Analizador::cbfrec2(Fl_Widget* pmenu, void *pany){
     Analizador* pana = (Analizador*)pany;
     pana->cbfrec2_in();
}


void Analizador::cbfrec2_in(){
     
}

/*******************************************************************************
* Analizador::cbfrec1: Callback para la tercera frecuencia de muestreo seleccio-
*                      nada en el menú.
*
*******************************************************************************/

void Analizador::cbfrec3(Fl_Widget* pmenu, void *pany){
     Analizador* pana = (Analizador*)pany;
     pana->cbfrec3_in();
}

void Analizador::cbfrec3_in(){
     
}


/*******************************************************************************
* Analizador::cbfrec1: Callback para la cuarta frecuencia de muestreo seleccio-
*                      nada en el menú.
*
*******************************************************************************/

void Analizador::cbfrec4(Fl_Widget* pmenu, void *pany){
     Analizador* pana = (Analizador*)pany;
     pana->cbfrec4_in();
}


void Analizador::cbfrec4_in(){
     
}

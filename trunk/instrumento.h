// Class automatically generated by Dev-C++ New Class wizard
		
#ifndef INSTRUMENTO_H
#define INSTRUMENTO_H
#include <string.h>
#include <stdlib.h>
#include <FL/Fl_Ask.H>

#pragma hdrstop
#include <stdio.h>
#include <windows.h>
#include "_mpusbapi.h"         // Archivo de cabecera para el enlace con la DLL 
                               // que provee Microchip para la comunicacion USB          
#pragma argsused*/

#define SIZE_DATA 150          // Maximo tamaño del vector recibido desde el hardawre 
#define DATA_OSC  572          // Tamaño del vector de datos para las graficas del osciloscopio 


/**
 * La clase Instrumento es la clase base para los cuatro instrumentos
 * que conforman el LIV y representa las caracteristicas generales que 
 * poseen. 
*/
class Instrumento	
{
	public:
		// Constructor de Clase
		Instrumento();
		// Destructor de clase
		~Instrumento();
		/**
		 * La función archivar genera un archivo plano con los datos 
		 * enviados por el hardware del intrumento.
		*/
		void archivar();
		/**
		 * La función Setnum_datos asigna el valor de la variable
		 * num_datos que contiene el numero de datos almacenados en el 
         * arreglo idatos[]. 
		*/
		void Setnum_datos(int x); 
        /**
		 * La función Setarchivo asigna el valor de la variable
		 * barchivo para habilitar el almacenamiento en archivos de texto.
		*/		
		void Setarchivo(bool x); 
		/**
		 * La función Sethardware asigna el valor de la variable
		 * bhardware que indica el estado del hardware.
		*/
        void Sethardware(bool x); 
        /**
		 * La función activar asigna el valor de la variable estado.
		*/
		void activar(bool bx); 
		/**
		 * La función Transmision realiza la comunicación
		 * con el hardware a través de USB.
		*/
		void Transmision();
		/**
		 * La función Encapsular organiza la trama que se envía
		 * al hardware a través de USB.
		*/
		void GuardarBit(int canal[], int posicion, bool bit);
		/**
		 * La función GuardarBit guarda el bit como caracter en los
		 * respectivos bufferes correspondientes a los canales del analizador
		 * lógico.
		**/
		void Encapsular(char, char, char, char);
		/**
		 * La función Desencapsular organiza los datos enviados desde el hardware
		 * a los instrumentos de software a través de USB.
		*/
		void Desencapsular(BYTE []);
		/**
		 * Almacena los identificadores de producto y vendedor
        */
		char vid_pid[18];
		/**
		 * Cadena con el número del endpoint de salida para
         * comunicación USB.
	    */
		char out_pipe[11];
		/**
		 * Cadena con el número del endpoint de entrada para
		 * comunicación USB
	    */
        char in_pipe[11];
        /**
		 * Apunta al handle del endpoint pipe de salida para la
		 * comunicación USB
	    */
        HANDLE myOutPipe;
        /**
		 * Apunta al handle del endpoint pipe de entrada para la
		 * comunicación USB
	    */
        HANDLE myInPipe;
        /**
		 * Buffer donde se encapsula los comandos enviados al hardware
		 * para la comunicación USB
	    */
        BYTE trama_control[SIZE_DATA];
        /**
		 * Buffer donde se almacena la información enviada desde el hardware
	    */
	    BYTE receive_buf[SIZE_DATA];
	    /**
		 * Buffer donde se almacena la información desencapsulada 
         * enviada desde el hardware por el osciloscopio.
	    */
	    char receive_buf_osc[572];
	    /**
		 * Variable que indica si el hardware ya completo de tomar las muestras 
         * de la señal en el canal 1 del osciloscopio.
	    */
	    bool ch1_muestreado;
	    /**
		 * Variable que indica si el hardware ya completo de tomar las muestras 
         * de la señal en el canal 2 del osciloscopio.
	    */
	    bool ch2_muestreado;
	    /**
		 * Buffer donde se almacena la información desencapsulada 
         * enviada desde el hardware por el osciloscopio al canal 1.
	    */
	    int buf_osc_ch1[DATA_OSC];
	    /**
		 * Variable donde se almacena el dato muestreado uno por uno 
         * enviado desde el hardware por el canal 1 del osciloscopio.
	    */
	    unsigned int idato_osc_ch1;
	    /**
		 * Variable donde se almacena el dato muestreado uno por uno 
         * enviado desde el hardware por el canal 2 del osciloscopio.
	    */
	    int idato_osc_ch2;
	    /**
		 * Buffer donde se almacena la información desencapsulada 
         * enviada desde el hardware por el osciloscopio al canal 2.
	    */
	    char buf_osc_ch2[DATA_OSC];
	    /**
		 * Buffers donde se almacena la información en caracter de los
		 * bits que se recibieron para el analizador logico.
	    */
	    int datos1[7], datos2[7], datos3[7], datos4[7], datos5[7],
            datos6[7], datos7[7], datos8[7];
	    /**
		 * Buffer donde se almacena la información desencapsulada 
         * enviada desde el hardware por el multimetro.
	    */
	    char buf_mult[4];
	    /**
		 * Arreglo con los datos de las señales digitalizados por el 
         * hardware del instrumento.
		*/
		int idatos[DATA_OSC];
		/**
		 * Esta variable representa el estado activo o inactivo del
		 * instrumento.
		*/
		bool bestado;
		/**
		 * Esta variable representa si se ha digitalizado datos para el
		 * instrumento.
		*/
		bool bmuestreado;
		/**
		 * Esta variable representa el numero de datos que se han
		 * almacenado provenientes del hardware del instrumento.
		*/
		int inum_datos;
		/**
		 * Contador de datos cuando se realiza un muestreo en el osciloscopio
		 * dato por dato.
		*/
		int icont_muestreo_unico;
		/**
		 * Esta variable representa el numero de datos que se han	recibido 
         * provenientes del hardware del instrumento excluyendo las cabeceras.
		*/
		int itamano_trama;
		/**
		 * Esta estructura es para guardar los bits para los canales del analizador
		 * logico.
	    **/
		struct CanalAnalizador {
            int BitUno : 1;
            int BitDos : 1;
            int BitTres : 1;
            int BitCuatro : 1;
            int BitCinco : 1;
            int BitSeis : 1;
            int BitSiete : 1;
            int BitOcho : 1;
        } Canal1, Canal2, Canal3, Canal4, Canal5, Canal6, Canal7, Canal8; 
	    
	protected:
		/**
		 * Esta variable representa el estado funcional del hardware del instrumento.
		*/
		bool bhardware;
		/**
		 * Esta variable representa la habilitación de la opción de guardar
		 * los datos adquiridos por los instrumentos en archivos planos. 
		*/
		bool barchivo;
		/**
		 * Esta variable contiene el nombre del archivo de texto donde se 
         * almacenan los datos del instrumento.
		*/
		char cnombre [12];
};

#endif // INSTRUMENTO_H

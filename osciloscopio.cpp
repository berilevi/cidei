// Class automatically generated by Dev-C++ New Class wizard

#include "osciloscopio.h" // class's header file

int isec_dual;            // Variable global para realizar la secuencia del menu dual 
int isec_trigger;         // Variable global para realizar la secuencia de la selección del canal fuente del trigger
int isec_acople;          // Variable global para realizar la secuencia del acople del canal 1
int isec_acople2;         // Variable global para realizar la secuencia del acople del canal 2
bool bsuma;               // Variable global que indica si se activó la operación de suma de las señales
bool bresta;              // Variable global que indica si se activó la operación de resta de las señales
bool bx_y;                // Variable global que indica si se activó la operación x vs y con las 2 señales 
bool btrigger1;           // Variable global que indica si se activó la fuente del trigger en el canal 1
bool btrigger2;           // Variable global que indica si se activó la fuente del trigger en el canal 2


// Constructor de clase
Osciloscopio::Osciloscopio(int x, int y, int w, int h, const char *l, int ncol) {
                                
    Fl_Tooltip::disable();                                        // Inicio desactivado de las ayudas flotantes
    icolor = ncol;                                                // Color de fondo de la pantalla del osciloscopio
    strcpy(cnombre,"osc.txt");                                    // Nombre para el archivo de texto donde se almacenan los datos
    ct_div = '1';                                                 // Variable para almacenar el caracter que se va a enviar de la escala de Tiempo por division
    
    
    //    Inicialización de las variables globales
    
    isec_trigger = 0;                                                      
    isec_acople = 0;          
    isec_acople2 = 0;
    isec_dual = 0;
    bsuma = 0;
    bresta = 0;
    bx_y = 0;
    btrigger1 = 0;
    btrigger2 = 0;
    
    
    
    {              
    ogroup_osc = new Fl_Group (5,5,725,360,"");                   // Inicia el grup de los elementos del osciloscopio
    ogroup_osc->box(FL_ENGRAVED_FRAME);                 
    ogroup_osc->box(FL_UP_BOX);
    ogroup_osc->deactivate();                           
    canal1 = new Canal(415,9,152,205,"",255);                     // Instancia de canal para crear el objeto canal 1
    canal2 = new Canal(573,9,152,205,"",250);                     // Instancia de canal para crear el objeto canal 2
    och1_on = new Fl_Light_Button(420,15,35,15,"ON");             // Botón para activar/desactivar el canal 1
    och1_on->labelsize(10);
    och1_on->tooltip("Botón para activar o desactivar el uso del canal 1");
    
    och2_on = new Fl_Light_Button(578,15,35,15,"ON");             // Botón para activar/desactivar el canal 2
    och2_on->labelsize(10);
    och2_on->tooltip("Botón para activar o desactivar el uso del canal 2");
    
    ogroup_dual = new Fl_Group (415,330,200,30,"");              //Inicio del grupo de los controles de las operaciones en modo dual
    ogroup_dual->box(FL_ENGRAVED_FRAME);
    ogroup_dual->deactivate();
    odual_menu = new Fl_Repeat_Button(425,336,40,18,"Dual");      //Botón para seleccionar la operación dual suma resta o lissajous 
    odual_menu->labelsize(10);
    odual_menu->deactivate();
    odual_menu->tooltip("Botón para seleccionar la operación dual de las gráficas");
    
    osuma = new Fl_Box(490,345,10,10,"Suma");                     // Indicador de la operación de suma de las dos señales
    osuma->labelsize(10);
    osuma->box(FL_ENGRAVED_BOX);
    osuma->align(FL_ALIGN_TOP);
    oresta = new Fl_Box(530,345,10,10,"Resta");                   // Indicador de la operación de resta de las dos señales
    oresta->labelsize(10);
    oresta->box(FL_ENGRAVED_BOX);
    oresta->align(FL_ALIGN_TOP);
    ox_y = new Fl_Box(570,345,10,10,"X_Y");                       // Indicador de la operación x vs y 
    ox_y->labelsize(9);
    ox_y->box(FL_ENGRAVED_BOX);
    ox_y->align(FL_ALIGN_TOP);
    ogroup_dual->end();                                           // Fin del grupo de controles de las operaciones en modo dual   
    
    olog_osc  = new Fl_Button (340,8,40,14,"Log");                // Boton para activar el almacenamiento en archivo de texto los datos
    olog_osc->labelsize(9);
    olog_osc->tooltip("Botón para iniciar a archivar los datos de las gráficas");
    
    ohelp_osc  = new Fl_Button (340,24,40,14,"Help");             // Botón que activa la ayuda del instrumento
    ohelp_osc->labelsize(10); 
    ohelp_osc->tooltip("Botón para iniciar el archivo de ayuda de uso del instrumento ");
    
    oayuda_osc  = new Fl_Check_Button (385,13,20,16,"?");         // Activa las ayudas flotantes de los botones del instrumento
    oayuda_osc->labelsize(12);
    oayuda_osc->tooltip("CheckBox para iniciar las ayudas flotantes del uso del los botones del instrumento");
    
    ogrilla_on = new Fl_Light_Button(250,13,45,17,"Grilla");      // Activa/desactiva la cuadricula de la pantalla del instrumento   
    ogrilla_on->labelsize(10);
    
    ogroup_tdiv = new Fl_Group (620,218,106,142,"");              //Inicia el grupo de los controles de tiempo por división
    ogroup_tdiv->box(FL_ENGRAVED_FRAME);
    ogroup_tdiv->deactivate();
    otiempo_div = new Fl_Knob (633,230,80,80,"T_DIV");            //Selector de la escala de tiempo por división
    otiempo_div->color(147);
    otiempo_div->type(8);
    otiempo_div->labelsize(9);
    otiempo_div->scaleticks(17);
    otiempo_div->range(0,17);
    otiempo_div->step(1);
    otiempo_div->round(1);
    //otiempo_div->tooltip("Selector de las escalas de tiempo por división del instrumento");
    
    omenu_t_div = new Fl_Choice(645,330,60,20,"");                //Menú selector de la escala de tiempo por división
    omenu_t_div->add("0.5 s",0,(Fl_Callback *)cb_tdiv05s,this);
    omenu_t_div->add("0.2 s",0,(Fl_Callback *)cb_tdiv02s,this);
    omenu_t_div->add("0.1 s",0,(Fl_Callback *)cb_tdiv01s,this);           
    omenu_t_div->add("50 m",0,(Fl_Callback *)cb_tdiv50ms,this);
    omenu_t_div->add("20 m",0,(Fl_Callback *)cb_tdiv20ms,this);
    omenu_t_div->add("10 m",0,(Fl_Callback *)cb_tdiv10ms,this);
    omenu_t_div->add("5 m",0,(Fl_Callback *)cb_tdiv5ms,this);
    omenu_t_div->add("2 m",0,(Fl_Callback *)cb_tdiv2ms,this);
    omenu_t_div->add("1 m",0,(Fl_Callback *)cb_tdiv1ms,this);
    omenu_t_div->add("0.5 m",0,(Fl_Callback *)cb_tdiv05ms,this);
    omenu_t_div->add("0.2 m",0,(Fl_Callback *)cb_tdiv02ms,this);
    omenu_t_div->add("0.1 m",0,(Fl_Callback *)cb_tdiv01ms,this);
    omenu_t_div->add("50 u",0,(Fl_Callback *)cb_tdiv50us,this);
    omenu_t_div->add("20 u",0,(Fl_Callback *)cb_tdiv20us,this);
    omenu_t_div->add("10 u",0,(Fl_Callback *)cb_tdiv10us,this);
    omenu_t_div->add("5 u",0,(Fl_Callback *)cb_tdiv5us,this);
    omenu_t_div->add("2 u",0,(Fl_Callback *)cb_tdiv2us,this);
    omenu_t_div->add("1 u",0,(Fl_Callback *)cb_tdiv1us,this);
    ogroup_tdiv->end();                                                   //Fin del grupo de controles de escala de tiempo por división
    
    ogroup_pos = new Fl_Group (415,218,100,110,"");                       //Inicio del grupo de controles de posición horizontal de las gráfica
    ogroup_pos->box(FL_ENGRAVED_FRAME);
    ogroup_pos->deactivate();           
    opos_y = new Fl_Knob (435,250,60,60,"X-Pos");                         //Perilla de dezplazamiento horizontal de las gráficas
    opos_y->color(180);
    opos_y->scaleticks(0);
    opos_y->cursor(40);
    opos_y->labelsize(10);
    opos_y->range(-100,100);
    //opos_y->tooltip("Boton de posicionamiento horizontal de las gráficas");
    ogroup_pos->end();                                                    //Fin del grupo de controles de posición horizontal de las gráficas   
    
    ostop = new Fl_Light_Button(420,222,35,30,"");                        //Botón para detención de las gráficas
    ostop->label("@|>");
    ostop->tooltip("Botón para detener la imagen graficada en el osciloscopio");
    
    ogroup_trigger = new Fl_Group (520,218,95,110,"");                    //Inicio del grupo de controles del trigger del instrumento        
    ogroup_trigger->box(FL_ENGRAVED_FRAME);
    ogroup_trigger->deactivate();
    osel_trigger = new Fl_Repeat_Button(528,230,40,18,"Trigger");         //Botón para seleccionar el canal que es la fuente del disparo
    osel_trigger->labelsize(10);
    osel_trigger->tooltip("Botón para seleccionar el canal fuente del trigger");
    
    otrigger_ch1 = new Fl_Box(577,225,10,10,"Ch1");                       //Indicador de canal 1 fuente del trigger      
    otrigger_ch1->labelsize(10);
    otrigger_ch1->box(FL_ENGRAVED_BOX);
    otrigger_ch1->align(FL_ALIGN_RIGHT);
    
    otrigger_ch2 = new Fl_Box(577,245,10,10,"Ch2");                       //Indicador de canal 2 fuente del trigger
    otrigger_ch2->labelsize(10);
    otrigger_ch2->box(FL_ENGRAVED_BOX);
    otrigger_ch2->align(FL_ALIGN_RIGHT);
    
    onivel_trigger = new Fl_Knob (540,255,57,57,"Nivel");                 //Perilla para seleccionar el nivel del trigger
    onivel_trigger->color(180);
    onivel_trigger->scaleticks(0);
    onivel_trigger->cursor(40);
    onivel_trigger->labelsize(10);
    onivel_trigger->range(0,10);
    ogroup_trigger->end();                                                // Fin del grupo de controles del trigger
                
    opantalla = new Fl_Scope(12,40,400,320,"");                           // Instancia de scope para la pantalla del osciloscopio
    opantalla->tracetype(FL_SCOPE_TRACE_LOOP);                            // Forma en que se colocan los datos para graficar
    opantalla->redrawmode(FL_SCOPE_REDRAW_ALWAYS);                        // La gráfica se redibuja cuando se adiciona cada dato                        
    opantalla->linetype(FL_SCOPE_LINE);                                   // La gráfica se forma con lineas entre dos puntos
    opantalla->box(FL_FLAT_BOX);                                          // La pantalla es un cuadro sin relieve
    
    Manual_osc = new Fl_Help_Dialog;                                      // Ventana de ayuda que sale al presionar el botón help
    Manual_osc->load("help_osciloscopio.html");                           // Cargar el archivo html que contiene la ayuda.
    
    ogroup_osc->end();                                                    //Fin del grupo de los elementos del osciloscopio
    }
    
    ogrilla = new grid(12,40,400,320,"");                                 //Instancia de la cuadricula para la pantalla 
    ogrilla->banalizador_on = 0;                                          //En cero para que no se active la grilla del analizador
    
    obox_nombre = new Fl_Box(15,8,175,30,"OSCILOSCOPIO");                 //Cuadro para colocar el nombre del instrumento
    obox_nombre->box(FL_ENGRAVED_FRAME);
    obox_nombre->labelfont(FL_HELVETICA_BOLD);
    obox_nombre->labelsize(20);
    
    oosc_on = new Fl_Light_Button(195,8,38,30,"ON");                      //Botón para encender o apagar el osciloscopio
    oosc_on->tooltip("Botón para encender o apagar el osciloscopio");
    oosc_on->labelsize(10);            
                
    // Callbacks de los botones del osciloscopio            
                
    och1_on->callback(cb_ch1_on,this);
    och2_on->callback(cb_ch2_on,this);
    odual_menu->callback(cb_dual_menu, this);    
    osel_trigger->callback(cb_sel_trigger, this);
    otiempo_div->callback(cb_tiempo_div, this);
    opos_y->callback(cb_pos_y, this);
    oosc_on->callback(cb_osc_on, this);
    olog_osc->callback(cb_log_osc, this);
    ogrilla_on->callback(cb_grilla, this);
    ostop->callback(cb_stop,this);
    oayuda_osc->callback(cb_ayuda, this);
    canal1->ovolt_div->callback(cb_volt_div1, this);
    canal1->osel_acople->callback(cb_acople1, this);
    canal2->ovolt_div->callback(cb_volt_div2, this);
    canal2->osel_acople->callback(cb_acople2, this);
    ohelp_osc->callback(cb_help,this);
}


/**
 * Este método es el callback del boton que enciende el osciloscopio  
*/
void Osciloscopio::cb_osc_on(Fl_Widget* pboton, void *pany){
     Osciloscopio* posc=(Osciloscopio*)pany;       //
     posc->cb_osc_on_in();
}

/**
 * Esta función acompaña la función  cb_osc_on para realizar los llamados al  
*/
void Osciloscopio::cb_osc_on_in(){
      if (oosc_on->value()== 1){                                
         activar(1);
         Encapsular('A','a','1','0',0x00,0x00);
         Transmision();
         if (bhardware){
            activar(1);
            ogroup_osc->activate(); 
            ogroup_tdiv->activate();
            ogroup_trigger->activate();
            ogroup_pos->activate(); 
            ogroup_dual->activate();    
            och1_on->value(1);
            canal1->activar(1);
            canal1->opos_x->value(0);
            canal1->ogroup_ch->activate();
            canal1->ogroup_ch->box(FL_UP_BOX);
            ogroup_tdiv->box(FL_UP_BOX);
            ogroup_trigger->box(FL_UP_BOX);
            otrigger_ch1->color(FL_RED);
            otrigger_ch1->redraw();
            btrigger1 = 1;
            isec_trigger = 1;
            ogroup_pos->box(FL_UP_BOX);
            ogroup_dual->box(FL_UP_BOX);
            otiempo_div->value(8);
            omenu_t_div->value(8);
            canal1->ovolt_div->value(0);
            canal1->omenu_v_div->value(0);
            canal1->oacop_ac->color(FL_RED);
            canal1->oacop_ac->redraw();
            isec_acople=1;
            opantalla->bch1 = 1;
            muestreo_timer(1);
         }
         else {
              fl_message("Error de hardware");
              oosc_on->value(0);
              oosc_on->box(FL_UP_BOX);
         }  
      }
      oosc_on->box(FL_DOWN_BOX);
      if (oosc_on->value()== 0){
         Fl::remove_timeout(cb_timer, this);
         Fl::remove_timeout(cb_timer_vectores, this);
         ogroup_tdiv->box(FL_ENGRAVED_BOX);
         ogroup_trigger->box(FL_ENGRAVED_BOX);
         ogroup_pos->box(FL_ENGRAVED_BOX);
         ogroup_dual->box(FL_ENGRAVED_BOX);
         oayuda_osc->value(0);
         Encapsular('A','b','1','0',0x00,0x00);         //Desactivar canal 1
         opantalla->bch1 = 0;
         Transmision();
         if (bhardware){
            och1_on->value(0);
            canal1->activar(0);
            canal1->~Canal();
            canal1->ogroup_ch->box(FL_ENGRAVED_BOX);
            canal1->ogroup_ch->deactivate();
         }
         else {
             fl_message("Error de hardware");
         }
         Encapsular('B','b','1','0',0x00,0x00);         //Desactivar canal 2
         opantalla->bch2 = 0;
         Transmision();
         if (bhardware){
           och2_on->value(0);
           canal2->activar(0);
           canal2->~Canal();
           canal2->ogroup_ch->box(FL_ENGRAVED_BOX);
           canal2->ogroup_ch->deactivate();
           odual_menu->deactivate();
         }
         else {
             fl_message("Error de hardware");
         }
         activar(0);
         opantalla->bch2 = 0;
         opantalla->bch1 = 0;
         opantalla->TraceColour(FL_BLACK);
         ogroup_osc->deactivate(); 
         ogroup_tdiv->deactivate();
         odual_menu->deactivate();
         isec_trigger = 0;
         otrigger_ch1->color(FL_GRAY);
         otrigger_ch1->redraw();
         btrigger1 = 0;
         otrigger_ch2->color(FL_GRAY);
         otrigger_ch2->redraw();
         btrigger2 = 0;         
         isec_acople = 0;          
         isec_acople2 = 0;
         isec_dual = -1;
         bsuma = 0;
         bresta = 0;
         bx_y = 0;
         osuma->color(FL_GRAY);
         osuma->redraw();
         oresta->color(FL_GRAY);
         oresta->redraw();
         ox_y->color(FL_GRAY);
         osuma->redraw();
         opantalla->bdual = 0;
         opantalla->blissajous = 0;
         oosc_on->box(FL_UP_BOX);
      }
}


/**
 *Callback del boton para activar o desactivar la grilla en la 
 * pantalla del osciloscopio
*/
void Osciloscopio::cb_grilla(Fl_Widget* pboton, void *pany){
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_grilla_in();
}


/**
 * Funcion que acompaña a la funcion cb_grilla para realizar los
 * llamados de callback para activar o desactivar la grilla en la 
 * pantalla del osciloscopio 
*/
void Osciloscopio::cb_grilla_in(){
     if (ogrilla_on->value()==1){
        ogrilla->bgrid = 1;
     }
     else{
         ogrilla->bgrid = 0; 
     }
     ogrilla->redraw();
}


/**
 *Callback del boton para detener la grafica en la pantalla del osciloscopio
*/
void Osciloscopio::cb_stop(Fl_Widget* pboton, void *pany){
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_stop_in();
}


/**
 * Funcion que acompaña a la funcion cb_stop para realizar los llamados de 
 * callback para detener en la pantalla del osciloscopio 
*/
void Osciloscopio::cb_stop_in(){
     if (ostop->value()==1){
        opantalla->bstop == 1;
        ostop->box(FL_DOWN_BOX);
     }
     else{
         opantalla->bstop == 0;
         ostop->box(FL_UP_BOX);
     }
}


/**
 * Callback del boton para encender el canal 1 del osciloscopio 
*/
void Osciloscopio::cb_ch1_on(Fl_Widget* pboton, void *pany){
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_ch1_on_in();
}


/**
 * Funcion que acompaña a la funcion cb_ch1_on para realizar los
 * llamados de callback para encender el canal 1 del osciloscopio 
*/
void Osciloscopio::cb_ch1_on_in(){
     if (och1_on->value()== 1){
        Fl::remove_timeout(cb_timer,this);
        Fl::remove_timeout(cb_timer_vectores,this);             
        Encapsular('A','a','1','0',0x00,0x00);                    //Activar canal 1
        Transmision();
        if (bhardware){
           canal1->activar(1);
           canal1->ogroup_ch->activate();
           canal1->ogroup_ch->box(FL_UP_BOX);
           opantalla->bch1 = 1;
           if (canal2->bestado== 1){
              odual_menu->activate();
           }
           if (otiempo_div->value() >= 8){                         // !!!! Toca cambiarlo a >= 2 
              Encapsular('L','d','1',ct_div,0x00,0x00);            // Configurar escala de Tiempo por division muestreo por vectores 
              Transmision();
              if (bhardware){
                 muestreo_timer(1);
              }
              else{
                   fl_message("Error de hardware");
              }
           }
           else {
                Encapsular('L','d','1','B',0x00,0x00);            //Configurar escala de Tiempo por division muestreo por vectores 
                Transmision();
                if (bhardware){
                   muestreo_timer(2);
                }
                else{
                   fl_message("Error de hardware");
                }
           }
        }
        else {
             fl_message("Error de hardware");
        }    
     }
     else{
        if (canal2->bestado== 0){                                        
           Fl::remove_timeout(cb_timer,this);
           Fl::remove_timeout(cb_timer_vectores,this);
        }
        Encapsular('A','b','1','0',0x00,0x00);                         //Desactivar canal 1
        opantalla->bch1 = 0;
        Transmision();
        if (bhardware){
           canal1->activar(0);
           canal1->ogroup_ch->box(FL_ENGRAVED_BOX);
           canal1->ogroup_ch->deactivate();
           odual_menu->deactivate();
        }
        else {
             fl_message("Error de hardware");
        }   
     }
}


/**
 * Callback del boton para encender el canal 2 del osciloscopio 
*/
void Osciloscopio::cb_ch2_on(Fl_Widget* pboton, void *pany){
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_ch2_on_in();
}

/**
 * Funcion que acompaña a la funcion cb_ch2_on para realizar los
 * llamados de callback para encender el canal 2 del osciloscopio 
*/
void Osciloscopio::cb_ch2_on_in(){
     if (och2_on->value()== 1){
        Fl::remove_timeout(cb_timer,this);
        Fl::remove_timeout(cb_timer_vectores,this);
        Encapsular('B','a','1','0',0x00,0x00);         //Activar canal 2
        Transmision();
        if (bhardware){
           canal2->activar(1);
           canal2->ogroup_ch->activate();
           canal2->ogroup_ch->box(FL_UP_BOX);
           //canal2->oacop_ac->value(1);
           canal2->oacop_ac->color(FL_GRAY);
           canal2->oacop_ac->redraw();
           canal2->ovolt_div->value(0);
           canal2->omenu_v_div->value(0);
           opantalla->bch2 = 1;
           if (canal1->bestado== 1){
              odual_menu->activate();
           }
           if (otiempo_div->value() >= 8){                          // !!!!  Toca cambiarlo a >= 2                
              Encapsular('L','d','1',ct_div,0x00,0x00);            //Configurar escala de Tiempo por division muestreo por vectores 
              Transmision();
              if (bhardware){
                 muestreo_timer(1);
              }
              else{
                   fl_message("Error de hardware");
              }
           }
           else {
                Fl::remove_timeout(cb_timer,this);
                Fl::remove_timeout(cb_timer_vectores,this);
                Encapsular('L','d','1','B',0x00,0x00);            //Configurar escala de Tiempo por division muestreo por vectores 
                Transmision();
                if (bhardware){
                   muestreo_timer(2);
                }
                else{
                   fl_message("Error de hardware");
                }
           }
        }
        else {
             fl_message("Error de hardware");
        }
     }
     else{
        if (canal1->bestado == 0){
           Fl::remove_timeout(cb_timer,this);
           Fl::remove_timeout(cb_timer_vectores,this);
           //opantalla->TraceColour(FL_BLACK);
        }
        Encapsular('B','b','1','0',0x00,0x00);                          //Desactivar canal 2
        opantalla->bch2 = 0;
        Transmision();
        if (bhardware){
           canal2->activar(0);
           canal2->ogroup_ch->box(FL_ENGRAVED_BOX);
           canal2->ogroup_ch->deactivate();
           odual_menu->deactivate();
        }
        else {
             fl_message("Error de hardware");
        } 
     }
}


/**
 * Este método es el callback del boton del menu de las funciones
 * duales de graficas en el osciloscopio, debe ir acompañada de una 
 * función inline para poder realizar los callbacks. 
*/
void Osciloscopio::cb_dual_menu(Fl_Widget* pboton, void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_dual_menu_in();
}

/**
 * Esta función acompaña la función  cb_menu_dual para realizar los llamados de 
 * callback del menu de funciones duales de graficas en el osciloscopio. 
*/
void Osciloscopio::cb_dual_menu_in(){
     if (isec_dual==0){
        ox_y->color(FL_GRAY);
        ox_y->redraw();
        bx_y = 0;
        bsuma = 1;
        osuma->color(FL_RED);
        osuma->redraw();
        opantalla->bdual = 1;
     }
     if (isec_dual==1){
        bsuma = 0;
        bresta = 1;
        osuma->color(FL_GRAY);
        osuma->redraw();
        oresta->color(FL_RED);
        oresta->redraw();
        opantalla->bdual = 1;
     }
     if (isec_dual==2){
        oresta->color(FL_GRAY);
        oresta->redraw();
        bresta = 0;
        bx_y = 1;
        ox_y->color(FL_RED);
        ox_y->redraw();
        opantalla->bdual = 1;
        opantalla->blissajous = 1;
     }
     if (isec_dual==3){
        ox_y->color(FL_GRAY);
        ox_y->redraw();
        bx_y = 0;
        opantalla->bdual = 0;
        opantalla->blissajous = 0;
        isec_dual=-1;
     }
     isec_dual++;
}

/**
 * Este método es el callback del boton selector de la fuente del 
 * disparo (trigger) en el osciloscopio, debe ir acompañada de una 
 * función inline para poder realizar los callbacks.  
*/
void Osciloscopio::cb_sel_trigger(Fl_Widget* pboton, void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_sel_trigger_in();
}

/**
 * Esta función acompaña la función  cb_sel_trigger para realizar 
 * los llamados de callback del boton selector de la fuente del
 * trigger en el osciloscopio 
*/
void Osciloscopio::cb_sel_trigger_in(){
     if (isec_trigger==0){
        otrigger_ch2->color(FL_GRAY);
        otrigger_ch2->redraw();
        otrigger_ch1->color(FL_RED);
        otrigger_ch1->redraw();
     }
     if (isec_trigger==1){
        otrigger_ch1->color(FL_GRAY);
        otrigger_ch1->redraw();
        otrigger_ch2->color(FL_RED);
        otrigger_ch2->redraw();
        isec_trigger=-1;
     }
     isec_trigger++;
}

/**
 * Este método es el callback del boton selector de la escala de 
 * tiempo por división en el osciloscopio, debe ir acompañada de una 
 * función inline para poder realizar los callbacks.  
*/
void Osciloscopio::cb_tiempo_div(Fl_Widget* psel, void *pany)
{
     Fl_Knob *pselector = (Fl_Knob *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tiempo_div_in(pselector);
}

/**
 * Esta función acompaña la función  cb_tiempo_div para realizar los llamados de 
 * callback del boton selector de la escala de tiempo por división en el 
 * osciloscopio. 
*/
void Osciloscopio::cb_tiempo_div_in(Fl_Widget* psel){
     Fl_Knob *pselector = (Fl_Knob *)psel;
     omenu_t_div->value(pselector->value());
     if (pselector->value()>=8){                                   // !!!!! Toca cambiarlo a >= 2 
                                                                   // !!! agregar las tramas de protocolo faltantes   
     
        if (pselector->value()== 8){
           ct_div = '1';                                     //Convertir a caracter la escala de tiempo por division
        } 
        else if (pselector->value() == 9){
            ct_div = '2';                                    //Convertir a caracter la escala de tiempo por division 
        } 
        else if (pselector->value() == 10){
            ct_div = '3';                                    //Convertir a caracter la escala de tiempo por division 
        } 
        else if (pselector->value() == 11){
            ct_div = '4';                                    //Convertir a caracter la escala de tiempo por division 
        } 
        else if (pselector->value() == 12){
            ct_div = '5';                                    //Convertir a caracter la escala de tiempo por division 
        } 
        else if (pselector->value() == 13){
            ct_div = '6';                                    //Convertir a caracter la escala de tiempo por division 
        }   
        else if (pselector->value() == 14){
            ct_div = '7';                                    //Convertir a caracter la escala de tiempo por division 
        }
        else if (pselector->value() == 15){
            ct_div = '8';                                    //Convertir a caracter la escala de tiempo por division 
        }
        else if (pselector->value() == 16){
            ct_div = '9';                                    //Convertir a caracter la escala de tiempo por division 
        }
        else if (pselector->value() == 17){
            ct_div = 'A';                                    //Convertir a caracter la escala de tiempo por division 
        }    
        Encapsular('L','d','1',ct_div,0x00,0x00);            //Configurar Tiempo por division 
        Fl::remove_timeout(cb_timer,this);
        Fl::remove_timeout(cb_timer_vectores,this); 
        Transmision();
        if (bhardware){
           muestreo_timer(1);
        }
        else
             fl_message("Error de hardware");
     }
     else {
          Encapsular('L','d','1','B',0x00,0x00);                          // !!!!!cambiar 'B' por 'F'
          Fl::remove_timeout(cb_timer,this);
          Fl::remove_timeout(cb_timer_vectores,this);        
          Transmision();
          if (bhardware)
             muestreo_timer(2);   
     }
}

/**
 * Este método es el callback del selector de la escala de volt/div
 * del canal 1 del osciloscopio debe ir acompañada de una función 
 * inline para poder realizar los callbacks. 
*/
void Osciloscopio::cb_volt_div1(Fl_Widget* psel, void *pany)
{
     Fl_Knob *pselector = (Fl_Knob *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;          
     posc->cb_volt_div1_in(pselector);
}

/**
 * Esta función acompaña la función  cb_volt_div1  
 * para realizar los llamados de callback del selector de la escala
 * de volt/div del canal en el osciloscopio 
*/
void Osciloscopio::cb_volt_div1_in(Fl_Widget* psel){
     Fl_Knob *pselector = (Fl_Knob *)psel;
     canal1->omenu_v_div->value(pselector->value());                
     if (int((pselector->value()))== 9){
         Encapsular('A','c','1','A',0x00,0x00);
         Transmision();
     }
     else if (int((pselector->value()))== 10){
        Encapsular('A','c','1','B',0x00,0x00);
         Transmision();
     }
     else if (int((pselector->value()))== 11){
         Encapsular('A','c','1','C',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 0){
         Encapsular('A','c','1','1',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 1){
         Encapsular('A','c','1','2',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 2){
         Encapsular('A','c','1','3',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 3){
         Encapsular('A','c','1','4',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 4){
         Encapsular('A','c','1','5',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 5){
         Encapsular('A','c','1','6',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 6){
         Encapsular('A','c','1','7',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 7){
         Encapsular('A','c','1','8',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 8){
         Encapsular('A','c','1','9',0x00,0x00);
         Transmision();                            
     }
}


/**
 * Este método es el callback del selector de la escala de volt/div
 * del canal 2 del osciloscopio debe ir acompañada de una función 
 * inline para poder realizar los callbacks. 
*/
void Osciloscopio::cb_volt_div2(Fl_Widget* psel, void *pany){
     Fl_Knob *pselector = (Fl_Knob *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;          
     posc->cb_volt_div2_in(pselector);
}

      
/**
 * Esta función acompaña la función  cb_volt_div2  
 * para realizar los llamados de callback del selector de la escala
 * de volt/div del canal en el osciloscopio 
*/
void Osciloscopio::cb_volt_div2_in(Fl_Widget* psel){
     Fl_Knob *pselector = (Fl_Knob *)psel;
     canal2->omenu_v_div->value(pselector->value());                
     if (int((pselector->value()))== 9){
         Encapsular('B','c','1','A',0x00,0x00);
         Transmision();
     }
     else if (int((pselector->value()))== 10){
        Encapsular('B','c','1','B',0x00,0x00);
         Transmision();
     }
     else if (int((pselector->value()))== 11){
         Encapsular('B','c','1','C',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 0){
         Encapsular('B','c','1','1',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 1){
         Encapsular('B','c','1','2',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 2){
         Encapsular('B','c','1','3',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 3){
         Encapsular('B','c','1','4',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 4){
         Encapsular('B','c','1','5',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 5){
         Encapsular('B','c','1','6',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 6){
         Encapsular('B','c','1','7',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 7){
         Encapsular('B','c','1','8',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 8){
         Encapsular('B','c','1','9',0x00,0x00);
         Transmision();                            
     }
}


/**
 * Este método es el callback del boton selector de la posición 
 * de la señal respecto al eje y en el osciloscopio, debe ir acompañada 
 * de una función inline para poder realizar los callbacks.  
*/
void Osciloscopio::cb_pos_y(Fl_Widget* psel, void *pany)
{
     Fl_Knob *pselector = (Fl_Knob *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_pos_y_in(pselector);
}

/**
 * Esta función acompaña la función  cb_pos_y 
 * para realizar los llamados de callback del boton selector de la
 * posición de la señal respecto al eje y en el osciloscopio 
*/
void Osciloscopio::cb_pos_y_in(Fl_Widget* psel){
     Fl_Knob *pselector = (Fl_Knob *)psel;
     pselector->value(floor(pselector->value()));
     opantalla->ipos_x =  int(pselector->value());
     ogrilla->redraw(); 
     opantalla->redraw();  
}

/**
 * Este método es el callback del timer para realizar la solicitud 
 * de datos uno a uno en el osciloscopio.  
*/
void Osciloscopio::cb_timer(void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_timer_in();
}

/**
 * Esta función acompaña la función cb_timer para realizar los llamados 
 * de callback del timer de solicitud de muestras una a una 
*/
void Osciloscopio::cb_timer_in(){
     Encapsular('L','y','1','0',0x00,0x00);
     Transmision();
     if (canal1->bestado && canal2->bestado){     
        recorrer_datos(3);
     }
     else if (canal1->bestado== 1 && canal2->bestado== 0){
          recorrer_datos(1);
     }
     else if (canal1->bestado== 0 && canal2->bestado== 1){
          recorrer_datos(2);
     }
     //if(omenu_t_div->value()== 0){
     if(otiempo_div->value()== 0){
        Fl::repeat_timeout(0.5, cb_timer, this);
     }
     //else if(omenu_t_div->value()== 1){
     if(otiempo_div->value()== 1){
        Fl::repeat_timeout(0.2, cb_timer, this);
     }
     //else if(omenu_t_div->value()== 2){
     if(otiempo_div->value()== 2){
        Fl::repeat_timeout(0.1, cb_timer, this);
     }
     //else if(omenu_t_div->value()== 3){
     if(otiempo_div->value()== 3){
        Fl::repeat_timeout(0.05, cb_timer, this);
     }
     //else if(omenu_t_div->value()== 4){
     if(otiempo_div->value()== 4){
        Fl::repeat_timeout(0.02, cb_timer, this);
     }
     //else if(omenu_t_div->value()== 5){
     if(otiempo_div->value()== 5){
        Fl::repeat_timeout(0.01, cb_timer, this);
     }
     //else if(omenu_t_div->value()== 6){
     if(otiempo_div->value()== 6){
        Fl::repeat_timeout(0.005, cb_timer, this);
     }
     //else if(omenu_t_div->value()== 7){
     if(otiempo_div->value()== 7){
        Fl::repeat_timeout(0.002, cb_timer, this);
     }
}


/**
 * Este método es el callback del timer para realizar la solicitud 
 * de vectores de datos del osciloscopio.  
*/
void Osciloscopio::cb_timer_vectores(void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_timer_vectores_in();
}


/**
 * Esta función acompaña la función cb_timer para realizar los llamados 
 * de callback del timer de solicitud de muestras por vectores de datos 
*/
void Osciloscopio::cb_timer_vectores_in(){
     if (canal1->bestado && ~canal2->bestado){
        Encapsular('L', 'p', '1', '0',0x00,0x00);                //Trama Osc14   
        Transmision();
        if (ch1_muestreado){
           Encapsular('A', 'p', '1', '1',0x00,0x00);             //Trama Osc16 
           Transmision();
           Encapsular('A', 'p', '1', '2',0x00,0x00);             //Trama Osc16
           Transmision();
           Encapsular('A', 'p', '1', '3',0x00,0x00);             //Trama Osc16
           Transmision();
           Encapsular('A', 'p', '1', '4',0x00,0x00);             //Trama Osc16
           Transmision();
           if (ostop->value() == 0)                              // Si esta presionado el boton de stop, no grafique
              recorrer_datos(1);
        }
     }
     if (canal2->bestado && ~canal1->bestado){
        Encapsular('L', 'p', '1', '0',0x00,0x00);
        Transmision();
        if (ch2_muestreado){
           Encapsular('B', 'p', '1', '1',0x00,0x00);
           Transmision();
           Encapsular('B', 'p', '1', '2',0x00,0x00);
           Transmision();
           Encapsular('B', 'p', '1', '3',0x00,0x00);
           Transmision();
           Encapsular('B', 'p', '1', '4',0x00,0x00);
           Transmision();
           if (ostop->value() == 0)
              recorrer_datos(2);
        }
     }
     if (canal1->bestado && canal2->bestado){
        Encapsular('L', 'p', '1', '0',0x00,0x00);
        Transmision();
        if (ch1_muestreado && ch2_muestreado){
           Encapsular('A', 'p', '1', '1',0x00,0x00);
           Transmision();
           Encapsular('A', 'p', '1', '2',0x00,0x00);
           Transmision();
           Encapsular('A', 'p', '1', '3',0x00,0x00);
           Transmision();
           Encapsular('A', 'p', '1', '4',0x00,0x00);
           Transmision();
           Encapsular('B', 'p', '1', '1',0x00,0x00);
           Transmision();
           Encapsular('B', 'p', '1', '2',0x00,0x00);
           Transmision();
           Encapsular('B', 'p', '1', '3',0x00,0x00);
           Transmision();
           Encapsular('B', 'p', '1', '4',0x00,0x00);
           Transmision();
           if (ostop->value() == 0)
              recorrer_datos(3);
        }
     }
    Fl::repeat_timeout(0.05, cb_timer_vectores, this); 
}



/**
 * La función recorrer_datos recorre el arreglo idatos y envia punto 
 * por punto los datos para graficar.
*/
void Osciloscopio::recorrer_datos(int num_canal){
     int icont;
     if (num_canal == 1){
     opantalla->TraceColour(Fl_Color(canal1->ncolor));
     free(opantalla->ScopeData2);
        //if (omenu_t_div->value()<8){                           // !!!!!!!!!Toca cambiarlo a < 2 
        if (otiempo_div->value()<8){
           idato_graf_ch1 = idato_osc_ch1;
           opantalla->Add((canal1->opos_x->value()*255)+(idato_graf_ch1*255),255); //es
           ogrilla->redraw();
        }
        else{
             for(icont=0;icont < DATA_OSC-1; icont++){
                 idato_graf_ch1 = buf_osc_ch1[icont];
                 opantalla->Add((canal1->opos_x->value()*255)+(idato_graf_ch1*255),255); //es 
                 ogrilla->redraw();           
             }   
        }                
     }
     if (num_canal == 2){
        opantalla->TraceColour(Fl_Color(canal2->ncolor));
        //if (omenu_t_div->value()<8){                                // !!!!!!!!!Toca cambiarlo a < 2 
        if (otiempo_div->value()<8){
           idato_graf_ch2 = idato_osc_ch2;
           opantalla->Add(255,(canal2->opos_x->value()*255)+(idato_graf_ch2*255)); //es
           ogrilla->redraw();
        }
        else{
            for(icont=0;icont < DATA_OSC-1; icont++){ 
                idato_graf_ch2 = buf_osc_ch2[icont];
                opantalla->Add(255,(canal2->opos_x->value()*255)+(idato_graf_ch2*255)); //es
                ogrilla->redraw();
            }
        }                 
     }
     if (num_canal == 3){
        //if (omenu_t_div->value() < 8){                                  // !!!!!!!!!Toca cambiarlo a < 2 
        if (otiempo_div->value()<8){
           opantalla->TraceColour(Fl_Color(canal2->ncolor));           
           idato_graf_ch2 = idato_osc_ch2;
           idato_graf_ch1 = idato_osc_ch1; 
           //if (osuma->value()){
           //if (isec_dual == 0){
           if (bsuma == 1){
              opantalla->Add((canal1->opos_x->value()*255)+((idato_graf_ch2*255)+(idato_graf_ch1*255)),255); //es
              ogrilla->redraw();
           }
           //else if(oresta->value()){
           //else if (isec_dual == 1){
           else if (bresta == 1){
               opantalla->Add((canal1->opos_x->value()*255)+((idato_graf_ch2*255)-(idato_graf_ch1*255)),255); //es 
               ogrilla->redraw(); 
           }
           //else if (ox_y->value()){
           //if (isec_dual == 2){
           else if (bx_y == 1){     
                opantalla->bdual = 1;
                opantalla->blissajous = 1;
                opantalla->Add((canal1->opos_x->value()*255)+(idato_graf_ch1*255),(canal2->opos_x->value()*255)+(idato_graf_ch2*255)); //es
                ogrilla->redraw();
           }
           //else if (isec_dual != 0 && isec_dual != 1 && isec_dual != 2){
           else if (bx_y == 0 && bsuma == 0 && bresta == 0){       
                opantalla->Add((canal1->opos_x->value()*255)+(idato_graf_ch1*255),(canal2->opos_x->value()*255)+(idato_graf_ch2*255)); //es
                ogrilla->redraw();
           }
        }
        else{
            for(icont=0;icont < DATA_OSC-1; icont++){
                idato_graf_ch1 = buf_osc_ch1[icont];
                idato_graf_ch2 = buf_osc_ch2[icont];
                //if (osuma->value()){
                //if (isec_dual == 0){
                if (bsuma == 1){          
                   opantalla->Add((canal1->opos_x->value()*255)+((idato_graf_ch2*255)+(idato_graf_ch1*255)),255); //es  
                   ogrilla->redraw();              
                }
                //else if (oresta->value()){
                //else if (isec_dual == 1){
                else if (bresta == 1){     
                   opantalla->Add((canal1->opos_x->value()*255)+((idato_graf_ch2*255)-(idato_graf_ch1*255)),255); //es 
                   ogrilla->redraw();               
                }
                //else if (ox_y->value()){
                //if (isec_dual == 2){
                else if (bx_y == 1){              
                   opantalla->bdual = 1;
                   opantalla->blissajous = 1;
                   opantalla->Add((idato_graf_ch1*255),(idato_graf_ch2*255)); 
                   ogrilla->redraw();           
                }
                else if (bx_y == 0 && bsuma == 0 && bresta == 0){
                     opantalla->Add((canal1->opos_x->value()*255)+(idato_graf_ch1*255),(canal2->opos_x->value()*255)+(idato_graf_ch2*255)); //es
                     ogrilla->redraw();
                }
            }              
        }                   
     }      
}


/**
 * Este método es el callback del boton que activa el almacenamiento en 
 * archivos planos de texto de los datos capturados para el osciloscopio,  
 * debe ir acompañada de una función inline para poder realizar los callbacks. 
*/
void Osciloscopio::cb_log_osc(Fl_Widget* pboton, void *pany){
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_log_osc_in();
}

/**
 * Esta función acompaña la función  cb_log_osc para realizar los 
 * llamados de callback del boton que activa el almacenamiento en archivos
 * planos de texto de los datos capturados para el osciloscopio. 
*/
void Osciloscopio::cb_log_osc_in(){
    ofstream log("osciloscopio.txt");
    for(int icont=0;icont < DATA_OSC-1; icont++){
         log << buf_osc_ch1[icont] << endl;             
    }
	log.close(); 
}


/**
 * Rutina para solicitar las muestras de las señales en el osciloscopio. 
*/
void Osciloscopio::muestreo_timer(int isel){
     if (isel==1){
        Fl::add_timeout(0.2, cb_timer_vectores, this);
     }
     else{
        Fl::add_timeout(0.3, cb_timer, this);
     }
}


/**
 * Este método es el callback del boton selector de acople
 * del canal 1del osciloscopio debe ir acompañada de una función 
 * inline para poder realizar los callbacks. 
*/
void Osciloscopio::cb_acople1(Fl_Widget* pboton, void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;       
     posc->cb_acople1_in();
}


/**
 * Esta función acompaña la función  cb_acople  
 * para realizar los llamados de callback del selector de acople
 * del canal 1 en el osciloscopio 
*/
void Osciloscopio::cb_acople1_in(){
  if (isec_acople==0){
     //canal1->oacop_gnd->value(0);
     canal1->oacop_gnd->color(FL_GRAY);
     canal1->oacop_gnd->redraw();
     Encapsular('A', 'e', '1', '2',0x00,0x00);
     Transmision();
     if (bhardware){
        //canal1->oacop_ac->value(1);
        canal1->oacop_ac->color(FL_RED);
        canal1->oacop_ac->redraw();
     }
     else{
         fl_message("Error de hardware"); 
     }
  }
  if (isec_acople==1){
     //canal1->oacop_ac->value(0);
     canal1->oacop_ac->color(FL_GRAY);
     canal1->oacop_ac->redraw();
     Encapsular('A', 'e', '1', '1',0x00,0x00);
     Transmision();
     if (bhardware){
        //canal1->oacop_dc->value(1);
        canal1->oacop_dc->color(FL_RED);
        canal1->oacop_dc->redraw();
     }
     else{
         fl_message("Error de hardware"); 
     }
  }
  if (isec_acople==2){
     //canal1->oacop_dc->value(0);
     canal1->oacop_dc->color(FL_GRAY);
     canal1->oacop_dc->redraw();
     Encapsular('A', 'e', '1', '3',0x00,0x00);
     Transmision();
      if (bhardware){
         //canal1->oacop_gnd->value(1);
         canal1->oacop_gnd->color(FL_RED);
         canal1->oacop_gnd->redraw();
      }
     else{
         fl_message("Error de hardware"); 
     }
     isec_acople=-1;
  }
     isec_acople++;  
}


/**
 * Este método es el callback del boton selector de acople
 * del canal 2 del osciloscopio debe ir acompañada de una función 
 * inline para poder realizar los callbacks. 
*/
void Osciloscopio::cb_acople2(Fl_Widget* pboton, void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;       
     posc->cb_acople2_in();
}


/**
 * Esta función acompaña la función  cb_acople2  
 * para realizar los llamados de callback del selector de acople
 * del canal 2 en el osciloscopio 
*/
void Osciloscopio::cb_acople2_in(){
  if (isec_acople2==0){
     //canal2->oacop_gnd->value(0);
     canal2->oacop_gnd->color(FL_GRAY);
     canal2->oacop_gnd->redraw();
     Encapsular('B', 'e', '1', '2',0x00,0x00);
     Transmision();
     if (bhardware){
        //canal2->oacop_ac->value(1);
        canal2->oacop_ac->color(FL_RED);
        canal2->oacop_ac->redraw();
     }
     else{
         fl_message("Error de hardware"); 
     }
  }
  if (isec_acople2==1){
     //canal2->oacop_ac->value(0);
     canal2->oacop_ac->color(FL_GRAY);
     canal2->oacop_ac->redraw();
     Encapsular('B', 'e', '1', '1',0x00,0x00);
     Transmision();
     if (bhardware){
        //canal2->oacop_dc->value(1);
        canal2->oacop_dc->color(FL_RED);
        canal2->oacop_dc->redraw();
     }
     else{
         fl_message("Error de hardware"); 
     }
  }
  if (isec_acople2==2){
     //canal2->oacop_dc->value(0);
     canal2->oacop_dc->color(FL_GRAY);
     canal2->oacop_dc->redraw();
     Encapsular('B', 'e', '1', '3',0x00,0x00);
     Transmision();
      if (bhardware){
         //canal2->oacop_gnd->value(1);
         canal2->oacop_gnd->color(FL_RED);
         canal2->oacop_gnd->redraw();
      }
     else{
         fl_message("Error de hardware"); 
     }
     isec_acople2=-1;
  }
     isec_acople2++;  
}


/**
 * 
 * 
*/
void Osciloscopio::cb_ayuda(Fl_Widget* pboton, void *pany){
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_ayuda_in();
}

/**
 * 
 *  
*/
void Osciloscopio::cb_ayuda_in(){
     if (oayuda_osc->value() == 1){
        Fl_Tooltip::enable();
     }
     else{
         Fl_Tooltip::disable(); 
     }
}



/**
 * 
*/
void Osciloscopio::cb_help(Fl_Widget* pboton, void *any){
     Osciloscopio* posc=(Osciloscopio*)any;
     posc->cb_help_in();
}

/**
 * 
*/
void Osciloscopio::cb_help_in(){
      Manual_osc->show();
}




/**
 * Callbacks para modificar el menu de tiempos por division de acuerdo a como 
 * se modifique la perilla selectora de tiempos por division en el osciloscopio. 
*/

void Osciloscopio::cb_tdiv05s(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv05s_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}

void Osciloscopio::cb_tdiv02s(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv02s_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}


void Osciloscopio::cb_tdiv01s(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv01s_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}


void Osciloscopio::cb_tdiv50ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv50ms_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}


void Osciloscopio::cb_tdiv20ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv20ms_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}


void Osciloscopio::cb_tdiv10ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv10ms_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}

void Osciloscopio::cb_tdiv5ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv5ms_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}


void Osciloscopio::cb_tdiv2ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv2ms_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}


void Osciloscopio::cb_tdiv1ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector); 
}

void Osciloscopio::cb_tdiv1ms_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}



void Osciloscopio::cb_tdiv05ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv05ms_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}

void Osciloscopio::cb_tdiv02ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv02ms_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}



void Osciloscopio::cb_tdiv01ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv01ms_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}


void Osciloscopio::cb_tdiv50us(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv50us_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}


void Osciloscopio::cb_tdiv20us(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector); 
}

void Osciloscopio::cb_tdiv20us_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}

void Osciloscopio::cb_tdiv10us(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv10us_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}

void Osciloscopio::cb_tdiv5us(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv5us_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}


void Osciloscopio::cb_tdiv2us(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector); 
}

void Osciloscopio::cb_tdiv2us_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}

void Osciloscopio::cb_tdiv1us(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv1us_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}


// Destructor de clase
Osciloscopio::~Osciloscopio(){
	// insert your code here
}

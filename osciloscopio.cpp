// Class automatically generated by Dev-C++ New Class wizard

#include "osciloscopio.h" // class's header file
#include <FL/Fl.H>

int isec_ch;              // Variable global para realizar la secuencia de la selección de canales 
int isec_dual;            // Variable global para realizar la secuencia del menu dual 
int isec_trigger;         // Variable global para realizar la secuencia del menu dual 


// class destructor
Osciloscopio::~Osciloscopio()
{
	// insert your code here
}


// sets the value of bsuma
void Osciloscopio::Setbsuma(bool bx)
{
	bsuma = bx;
}


// sets the value of bx_y
void Osciloscopio::Setbx_y(bool bx)
{
	bx_y = bx;
}


// sets the value of ipos_x
void Osciloscopio::Setipos_x(int ix)
{
	ipos_x = ix;
}


// sets the value of it_div
void Osciloscopio::Setit_div(int ix)
{
	it_div = ix;
}


// sets the value of ifrec_muestreo
void Osciloscopio::Setifrec_muestreo(int ix)
{
	ifrec_muestreo = ix;
}


// sets the value of nnivel_trigger
void Osciloscopio::Setinivel_trigger(int ix)
{
	inivel_trigger = ix;
}

// sets the value of bdual
void Osciloscopio::Setbdual(bool bx)
{
	bdual = bx;
}


/*
 * Método para realizar la gráfica de la pantalla y la 
 * cuadricula del osciloscopio
 */
void Osciloscopio::draw()
{
	 int icont1,icont2;
     fl_draw_box(FL_FLAT_BOX,8, 8, 380, 304, Fl_Color(icolor)); // Pantalla del osciloscopio
     fl_color(FL_DARK_GREEN);
     fl_line_style(0,0);
     fl_line(8, 152, 388, 152);             // Eje x
     fl_line(198, 8, 198, 312);             // Eje y
     if (bdual){                            // Para graficar suma, resta y lissajous
        fl_color(FL_WHITE);
        fl_line_style(0,0);
        for (icont1=0;icont1 < inum_datos-2;icont1++){   
             for (icont2=0;icont2 < 380;icont2++){
                  fl_line((itiempo[icont1]+8), (195-idatos[icont1]), ((itiempo[icont1+1])+8), (195-idatos[icont1+1]) );              
             }                    
         }
     }
}

/*
 * Método para sumar las señales adquiridas por los 2 canales
 * del instrumento.
 */
void Osciloscopio::sumar(int idato1[], int idato2[])
{
     int icont1;
     for (icont1=0; icont1 < inum_datos; icont1++){
         idatos[icont1] = idato1[icont1]+idato2[icont1]; // Suma de las dos señales para el eje y
         itiempo[icont1] = icont1;                       //Llenar el vector con valores para el eje x
     }
}

/*
 * Método para restar las señales adquiridas por los 2 canales
 * del instrumento 
 */
void Osciloscopio::restar(int idato1[], int idato2[])
{
     int icont1;
     for (icont1=0; icont1 < inum_datos; icont1++){
         idatos[icont1] = idato1[icont1] - idato2[icont1];    //Diferencia de las dos señales para el eje y
         itiempo[icont1] = icont1;                            //Llenar el vector con valores para el eje x
     }
}

/*
 * Método para realizar gráficas de lissajous con las señales 
 * de los 2 canales.
 */
void Osciloscopio::lissajous(int idato1[], int idato2[])
{
     int icont1;
     for (icont1=0; icont1 < inum_datos; icont1++){
         idatos[icont1] = idato1[icont1];                     //Datos del canal 1 para el eje y
         itiempo[icont1] = idato2[icont1];                    //Datos del canal 2 para el eje x 
     }
}

/*
 * Este método es el callback del boton selector de canales
 * en el osciloscopio
 */
void Osciloscopio::cb_sel_ch(Fl_Widget* pboton, void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;       //
     posc->cb_sel_ch_in();
}

/**
* Esta función acompaña la función  cb_sel_ch 
* para realizar los llamados de callback del selector de canales
* en el osciloscopio 
*/
void Osciloscopio::cb_sel_ch_in(){
     int ihilo_status;
     if (isec_ch==0){
     och2->value(0);
     canal2->ogroup_ch->deactivate();
     odual_menu->deactivate();
     och1->value(1);
     canal1->activar(1);
     canal1->ogroup_ch->activate();
     Fl::add_timeout(0.5, cb_timer, this);
     }
     if (isec_ch==1){
     och1->value(0);
     canal1->ogroup_ch->deactivate();
     Fl::remove_timeout(cb_timer, this);
     och2->value(1);
     canal2->ogroup_ch->activate();
     }
     if (isec_ch==2){
     och1->value(1);
     canal1->ogroup_ch->activate();
     odual_menu->activate();
     isec_ch=-1;
     }
     isec_ch++;
     pthread_join(thcanales[0], NULL);
     pthread_join(thcanales[1], NULL);
}

/**
 * Este método es el callback del boton del menu de las funciones
 * duales de graficas en el osciloscopio, debe ir acompañada de una 
 * función inline para poder realizar los callbacks. 
*/
void Osciloscopio::cb_dual_menu(Fl_Widget* pboton, void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_dual_menu_in();
}

/**
 * Esta función acompaña la función  cb_menu_dual 
 * para realizar los llamados de callback del menu de funciones duales
 * de graficas en el osciloscopio 
*/
void Osciloscopio::cb_dual_menu_in(){
     if (isec_dual==0){
     ox_y->value(0);
     osuma->value(1);
     }
     if (isec_dual==1){
     osuma->value(0);
     oresta->value(1);
     }
     if (isec_dual==2){
     oresta->value(0);
     ox_y->value(1);
     isec_dual=-1;
     }
     isec_dual++;
}

/**
 * Este método es el callback del boton selector de la fuente del 
 * disparo (trigger) en el osciloscopio, debe ir acompañada de una 
 * función inline para poder realizar los callbacks.  
*/
void Osciloscopio::cb_sel_trigger(Fl_Widget* pboton, void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_sel_trigger_in();
}

/**
 * Esta función acompaña la función  cb_sel_trigger para realizar 
 * los llamados de callback del boton selector de la fuente del
 * trigger en el osciloscopio 
*/
void Osciloscopio::cb_sel_trigger_in(){
     if (isec_trigger==0){
     otrigger_ch2->value(0);
     otrigger_ch1->value(1);
     }
     if (isec_trigger==1){
     otrigger_ch1->value(0);
     otrigger_ch2->value(1);
     isec_trigger=-1;
     }
     isec_trigger++;
}

/**
 * Este método es el callback del boton selector de la escala de 
 * tiempo por división en el osciloscopio, debe ir acompañada de una 
 * función inline para poder realizar los callbacks.  
*/
void Osciloscopio::cb_tiempo_div(Fl_Widget* psel, void *pany)
{
     Fl_Knob *pselector = (Fl_Knob *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tiempo_div_in(pselector);
}

/**
 * Esta función acompaña la función  cb_tiempo_div 
 * para realizar los llamados de callback del boton selector de la
 * escala de tiempo por división en el osciloscopio 
*/
void Osciloscopio::cb_tiempo_div_in(Fl_Widget* psel){
     Fl_Knob *pselector = (Fl_Knob *)psel;
     pselector->value(floor(pselector->value()));
     omenu_t_div->value(pselector->value());
}

/**
 * Este método es el callback del boton selector de la posición 
 * de la señal respecto al eje y en el osciloscopio, debe ir acompañada 
 * de una función inline para poder realizar los callbacks.  
*/
void Osciloscopio::cb_pos_y(Fl_Widget* psel, void *pany)
{
     Fl_Knob *pselector = (Fl_Knob *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_pos_y_in(pselector);
}

/**
 * Esta función acompaña la función  cb_pos_y 
 * para realizar los llamados de callback del boton selector de la
 * posición de la señal respecto al eje y en el osciloscopio 
*/
void Osciloscopio::cb_pos_y_in(Fl_Widget* psel){
     Fl_Knob *pselector = (Fl_Knob *)psel;
     pselector->value(floor(pselector->value()));
     ov_posx->value(pselector->value());
}

/**
 * Este método es el callback del timer
 * para realizar la solicitud de datos del osciloscopio al hardware.  
*/
void Osciloscopio::cb_timer(void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_timer_in();
}

/**
 * Esta función acompaña la función cb_timer
 * para realizar los llamados de callback del timer 
*/
void Osciloscopio::cb_timer_in(){
     canal1->Encapsular('A','P',0x3F,'0','0');
     canal1->Transmision();
     canal1->almacenar(canal1->itamano_trama,canal1->receive_buf2);
     canal1->recorrer_datos();
     Fl::repeat_timeout(0.2, cb_timer, this);
}


/**
 * Este método es el callback del hilo de ejecución del canal 
 * del osciloscopio.  
*/
void *Osciloscopio::cb_hilo(void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_hilo_in();
     return NULL;
}

/**
 * Esta función acompaña la función cb_hilo
 * para realizar los llamados de callback del hilo 
*/
void Osciloscopio::cb_hilo_in(){
    // Fl::add_timeout(0.5, cb_timer, this);
}

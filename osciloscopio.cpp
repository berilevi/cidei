// Class automatically generated by Dev-C++ New Class wizard

#include "osciloscopio.h" // class's header file

int isec_dual;            // Variable global para realizar la secuencia del menu dual 
int isec_trigger;         // Variable global para realizar la secuencia de la selección del canal fuente del trigger
int isec_acople;          // Variable global para realizar la secuencia del acople del canal 1
int isec_acople2;         // Variable global para realizar la secuencia del acople del canal 2
bool bsuma;               // Variable global que indica si se activó la operación de suma de las señales
bool bresta;              // Variable global que indica si se activó la operación de resta de las señales
bool bx_y;                // Variable global que indica si se activó la operación x vs y con las 2 señales 
bool btrigger1;           // Variable global que indica si se activó la fuente del trigger en el canal 1
bool btrigger2;           // Variable global que indica si se activó la fuente del trigger en el canal 2
int icont_datos;          // variable global que cuenta el numero de muestras graficadas. 
int imayor1 = 0;          // Inicializar el valor mayor para calcular el vpp del canal 1
int imenor1 = 510;        // Inicializar el valor menor para calcular el vpp del canal 1
int imayor2 = 0;          // Inicializar el valor mayor para calcular el vpp del canal 2
int imenor2 = 510;        // Inicializar el valor menor para calcular el vpp del canal 2
bool bacopleGnd1 = 0;     // Variable global que indica si el canal 1 está en acople gnd.
bool bacopleGnd2 = 0;     // Variable global que indica si el canal 2 está en acople gnd.


/*******************************************************************************
* Osciloscopio::Osciloscopio: Constructor de la clase Osciloscopio.
* Se inicializan las variables y se realizan las instancias de los objetos que
* hacen parte del instrumento en especial los 2 canales, la pantalla y demás 
* botones y controles con sus respectivos callbacks.  
*******************************************************************************/
Osciloscopio::Osciloscopio(){
                               
    Fl_Tooltip::disable();                                        // Inicio desactivado de las ayudas flotantes
   // strcpy(cnombre,"osc.txt");                                    // Nombre del para el archivo de texto donde se almacenan los datos
                                                    
    
    //    Inicialización de las variables globales
    ctDiv = '1';                                                   // Variable para almacenar el caracter que se va a enviar de la escala de Tiempo por division
    isec_trigger = 0;                                                      
    isec_acople = 0;          
    isec_acople2 = 0;
    isec_dual = 0;
    bsuma = 0;
    bresta = 0;
    bx_y = 0;
    btrigger1 = 0;
    btrigger2 = 0;
    ivppCh1 = 0;
    ivppCh2 = 0;
    icont_datos = 0;
                
    ogroupOsc = new Fl_Group (5,5,725,360,"");                   // Inicia el grupo de los elementos del osciloscopio
    ogroupOsc->box(FL_ENGRAVED_FRAME);                 
    ogroupOsc->box(FL_UP_BOX);
    ogroupOsc->deactivate();                       
    canal1 = new Canal(415,9,152,205,"",255);                     // Instancia de canal para crear el objeto canal 1
    canal2 = new Canal(573,9,152,205,"",250);                     // Instancia de canal para crear el objeto canal 2
    
    och1On = new Fl_Light_Button(424,15,49,15,"ON");             // Botón para activar/desactivar el canal 1
    och1On->labelsize(10);
    och1On->tooltip("Botón para activar o desactivar el uso del canal 1");
    
    och2On = new Fl_Light_Button(586,15,49,15,"ON");             // Botón para activar/desactivar el canal 2
    och2On->labelsize(10);
    //och2On->tooltip("Botón para activar o desactivar el uso del canal 2");
    
    
    ogroupDual = new Fl_Group (415,330,200,30,"");              //Inicio del grupo de los controles de las operaciones en modo dual
    ogroupDual->box(FL_ENGRAVED_FRAME);
    ogroupDual->deactivate();
    odualMenu = new Fl_Repeat_Button(425,336,40,18,"Dual");      //Botón para seleccionar la operación dual suma resta o lissajous 
    odualMenu->labelsize(10);
    odualMenu->deactivate();
    //odualMenu->tooltip("Botón para seleccionar la operación dual de las gráficas");
    
    osuma = new Fl_Box(490,345,10,10,"Suma");                     // Indicador de la operación de suma de las dos señales
    osuma->labelsize(10);
    osuma->box(FL_ENGRAVED_BOX);
    osuma->align(FL_ALIGN_TOP);
    oresta = new Fl_Box(530,345,10,10,"Resta");                   // Indicador de la operación de resta de las dos señales
    oresta->labelsize(10);
    oresta->box(FL_ENGRAVED_BOX);
    oresta->align(FL_ALIGN_TOP);
    oxy = new Fl_Box(570,345,10,10,"XY");                       // Indicador de la operación x vs y 
    oxy->labelsize(9);
    oxy->box(FL_ENGRAVED_BOX);
    oxy->align(FL_ALIGN_TOP);  
    ogroupDual->end();                                           // Fin del grupo de controles de las operaciones en modo dual   
    
    oautoSet  = new Fl_Button (370,8,5,5,"");             // Botón para activar el ajuste automático del instrumento
    oautoSet->labelsize(9);
    
    //ologOsc  = new Fl_Button (340,8,40,14,"Log");                // Boton para activar el almacenamiento en archivo de texto los datos
    ologOsc = new Fl_Button (328,8,38,30,"log");
    ologOsc->labelsize(9);
   // ologOsc->tooltip("Botón para iniciar a archivar los datos de las gráficas");
    
    //ohelpOsc  = new Fl_Button (370,24,40,14,"Help");             // Botón que activa la ayuda del instrumento
    //ohelpOsc->labelsize(9);
    //ohelpOsc->tooltip("Botón para iniciar el archivo de ayuda de uso del instrumento ");
    
    //oayudaOsc  = new Fl_Check_Button (385,13,20,16,"a");         // Activa las ayudas flotantes de los botones del instrumento
    oayudaOsc  = new Fl_Button (370,8,38,30,"?");
    oayudaOsc->labelsize(12);
    //oayudaOsc->tooltip("CheckBox para iniciar las ayudas flotantes del uso del los botones del instrumento");
    
    //ogrillaOn = new Fl_Light_Button(240,13,45,17,"Grilla");      // Activa/desactiva la cuadricula de la pantalla del instrumento   
    ogrillaOn = new Fl_Light_Button(290,8,38,30,"Grid");
    ogrillaOn->labelsize(10);
    ogrillaOn->tooltip("Cuadricula");
    
    ogroupTdiv = new Fl_Group (620,218,106,142,"");              //Inicia el grupo de los controles de tiempo por división
    ogroupTdiv->box(FL_ENGRAVED_FRAME);
    ogroupTdiv->deactivate();
    otiempoDiv = new Fl_Knob (635,270,78,78,"TDIV");            //Selector de la escala de tiempo por división
    otiempoDiv->color(147);
    otiempoDiv->type(8);
    otiempoDiv->labelsize(9);
    otiempoDiv->scaleticks(17);
    otiempoDiv->range(0,17);
    otiempoDiv->step(1);
    otiempoDiv->round(1);
    //otiempoDiv->tooltip("Selector de las escalas de tiempo por división del instrumento");
    
    omenuTdiv = new Fl_Choice(628,225,95,26,"");                //Menú selector de la escala de tiempo por división
    omenuTdiv->add("0.5s",0,(Fl_Callback *)cbTdiv05s,this);
    omenuTdiv->add("0.2s",0,(Fl_Callback *)cbTdiv02s,this);            
    omenuTdiv->add("0.1s",0,(Fl_Callback *)cbTdiv01s,this);            
    omenuTdiv->add("50ms",0,(Fl_Callback *)cbTdiv50ms,this);  
    omenuTdiv->add("20ms",0,(Fl_Callback *)cbTdiv20ms,this);  
    omenuTdiv->add("10ms",0,(Fl_Callback *)cbTdiv10ms,this);  
    omenuTdiv->add("5ms",0,(Fl_Callback *)cbTdiv5ms,this);  
    omenuTdiv->add("2ms",0,(Fl_Callback *)cbTdiv2ms,this);  
    omenuTdiv->add("1ms",0,(Fl_Callback *)cbTdiv1ms,this);  
    omenuTdiv->add("0.5ms",0,(Fl_Callback *)cbTdiv05ms,this); 
    omenuTdiv->add("0.2ms",0,(Fl_Callback *)cbTdiv02ms,this); 
    omenuTdiv->add("0.1ms",0,(Fl_Callback *)cbTdiv01ms,this); 
    omenuTdiv->add("50us",0,(Fl_Callback *)cbTdiv50us,this);  
    omenuTdiv->add("20us",0,(Fl_Callback *)cbTdiv20us,this);    
    omenuTdiv->add("10us",0,(Fl_Callback *)cbTdiv10us,this);  
    omenuTdiv->add("5us",0,(Fl_Callback *)cbTdiv5us,this);    
    omenuTdiv->add("2us",0,(Fl_Callback *)cbTdiv2us,this);    
    omenuTdiv->add("1us",0,(Fl_Callback *)cbTdiv1us,this);   
   
    ogroupTdiv->end();                                                   //Fin del grupo de controles de escala de tiempo por división
    
    ogroupPos = new Fl_Group (415,218,100,110,"");                       //Inicio del grupo de controles de posición horizontal de las gráfica
    ogroupPos->box(FL_ENGRAVED_FRAME);
    ogroupPos->deactivate();
    oposy = new Fl_Knob (448,220,60,60,"XPos");                         //Perilla de dezplazamiento horizontal de las gráficas
    oposy->color(180);
    oposy->scaleticks(0);
    oposy->cursor(40);
    oposy->labelsize(10);
    oposy->range(-100,100);
    //oposy->tooltip("Boton de posicionamiento horizontal de las gráficas");
    ogroupPos->end();                                                    //Fin del grupo de controles de posición horizontal de las gráficas    
    
    ostop = new Fl_Light_Button(420,282,23,23,"");                        //Botón para detención de las gráficas
    //ostop->label("@|>");
    //ostop->tooltip("Botón para detener la imagen graficada en el osciloscopio");
    
    ogroupTrigger = new Fl_Group (520,218,95,110,"");                    //Inicio del grupo de controles del trigger del instrumento        
    ogroupTrigger->box(FL_ENGRAVED_FRAME);
    ogroupTrigger->deactivate();
    oselTrigger = new Fl_Repeat_Button(528,230,40,18,"Trigger");         //Botón para seleccionar el canal que es la fuente del disparo
    oselTrigger->labelsize(10);
    //oselTrigger->tooltip("Botón para seleccionar el canal fuente del trigger");
        
    otriggerCh1 = new Fl_Box(577,225,10,10,"Ch1");                       //Indicador de canal 1 fuente del trigger      
    otriggerCh1->labelsize(10);
    otriggerCh1->box(FL_ENGRAVED_BOX);
    otriggerCh1->align(FL_ALIGN_RIGHT);
    
    otriggerCh2 = new Fl_Box(577,245,10,10,"Ch2");                       //Indicador de canal 2 fuente del trigger
    otriggerCh2->labelsize(10);
    otriggerCh2->box(FL_ENGRAVED_BOX);
    otriggerCh2->align(FL_ALIGN_RIGHT);
    
    onivelTrigger = new Fl_Knob (540,255,57,57,"Nivel");                 //Perilla para seleccionar el nivel del trigger
    onivelTrigger->color(180);
    onivelTrigger->scaleticks(0);
    onivelTrigger->cursor(40);
    onivelTrigger->labelsize(10);
    onivelTrigger->range(0,10);
    ogroupTrigger->end();                                                // Fin del grupo de controles del trigger
                
    opantalla = new Fl_Scope(10,43,400,320,"");                           // Instancia de scope para la pantalla del osciloscopio
    opantalla->tracetype(FL_SCOPE_TRACE_LOOP);                            // Forma en que se colocan los datos para graficar
    opantalla->redrawmode(FL_SCOPE_REDRAW_ALWAYS);                        // La gráfica se redibuja cuando se adiciona cada dato                        
    opantalla->linetype(FL_SCOPE_LINE);                                   // La gráfica se forma con lineas entre dos puntos
    opantalla->box(FL_FLAT_BOX);                                          // La pantalla es un cuadro sin relieve
    
    odispOsc1 = new DispOsc(12,40,200,40);
    odispOsc2 = new DispOsc(212,40,200,40);
    odispOsc1->TextColour(FL_YELLOW);
    odispOsc2->TextColour(FL_GREEN);
    
    manual = new Fl_Help_Dialog;                                      // Ventana de ayuda que sale al presionar el botón help
    manual->load("helpOsciloscopio.html");                            // Cargar el archivo html que contiene la ayuda.
    
    ogroupOsc->end();                                                    //Fin del grupo de los elementos del osciloscopio
    
    
    ogrilla = new grid(10,43,400,320,"");                                 //Instancia de la cuadricula para la pantalla 
    ogrilla->banalizador_on = 0;                                          //En cero para que no se active la grilla del analizador
    
    oboxNombre = new Fl_Box(15,8,175,30,"OSCILOSCOPIO");                 //Cuadro para colocar el nombre del instrumento
    oboxNombre->box(FL_ENGRAVED_FRAME);
    oboxNombre->labelfont(FL_HELVETICA_BOLD);
    oboxNombre->labelsize(20);
    
    ooscOn = new Fl_Light_Button(250,8,38,30,"");                      //Botón para encender o apagar el osciloscopio
    //ooscOn->tooltip("Botón para encender o apagar el osciloscopio");
    ooscOn->box(FL_NO_BOX);
    //ooscOn->labelsize(10);           
                
    // Callbacks de los botones del osciloscopio            
                
    och1On->callback(cbCh1On,this);                                    //Callback del botón de prender/apagar el canal 1
    och2On->callback(cbCh2On,this);                                    //Callback del botón de prender/apagar el canal 2
    odualMenu->callback(cbDualMenu, this);                             //Callback del botón que selecciona la operación suma, resta o xy
    oselTrigger->callback(cbSelTrigger, this);
    otiempoDiv->callback(cbTiempoDiv, this);
    oposy->callback(cbPosy, this);
    ooscOn->callback(cbOscOn, this);
    ologOsc->callback(cbLogOsc, this);
    ogrillaOn->callback(cbGrilla, this);
    ostop->callback(cbStop,this);
    oayudaOsc->callback(cbAyuda, this);
    canal1->ovoltDiv->callback(cbVoltDiv1, this);
    canal1->oselAcople->callback(cbAcople1, this);
    canal2->ovoltDiv->callback(cb_volt_div2, this);
    canal2->oselAcople->callback(cbAcople2, this);
    //ohelpOsc->callback(cbHelp,this);
   // oautoSet->callback(cbAuto,this);
}


/*******************************************************************************
* Osciloscopio::cbOscOn: Callback del botón que enciende/apaga el osciloscopio.
*
* Para los callbacks de los botones en las clases se deben tener 2 funciones que
* van juntas y se debe tener en cuenta las siguientes caracteristicas.
* Los Callbacks deben ser definidos como estaticos (static).
* La función declarada como static es una función simple que inicializa el 
* apuntador this de la clase y hace un llamado a una segunda función que se   
* declara como inline que es donde se realiza el codigo que se debe ejecutar en 
* el callback; la funcion inline no necesita parametros ya que tiene acceso a 
* todos los métodos y variables de la clase. 
*******************************************************************************/
void Osciloscopio::cbOscOn(Fl_Widget* pboton, void *pany){
     Osciloscopio* posc=(Osciloscopio*)pany;              //Casting  del apuntador void para que tenga el tamaño de un objeto Osciloscopio    
     posc->cbOscOnIn();                                //Llamado a la función inline sin argumentos.
}

/*******************************************************************************
* Osciloscopio::cbOscOnIn: Función inline del callback del botón que prende o  
*                          apaga el osciloscopio.
* Al encender el osciloscopio se inicia con las siguientes configuraciones por 
* defecto: canal 1 activado, 5 voltios por división, 1mS por división, acople ac
* y fuente de trigger canal 1. 
*******************************************************************************/
void Osciloscopio::cbOscOnIn(){
      if (ooscOn->value()== 1){                               
         activar(1);                                            
         Encapsular('A','a','1','0',0x00,0x00);                 //Trama de encendido del canal 1.
         Transmision();                                         //Transmitir al hardware la trama anterior
         if (bhardware){                                        //Si la respuesta fue ack la orden fue reconocida por el hardware
            activar(1);                                         //Activar el instrumento virtual osciloscopio
            ogroupOsc->activate(); 
            ogroupTdiv->activate();
            ogroupTrigger->activate();
            ogroupPos->activate(); 
            ogroupDual->activate();
            och1On->value(1);
            canal1->activar(1);
            canal1->oposx->value(0);
            canal1->ogroupCh->activate();
            canal1->ogroupCh->box(FL_UP_BOX);
            ogroupTdiv->box(FL_UP_BOX);
            ogroupTrigger->box(FL_UP_BOX);
            otriggerCh1->color(FL_RED);
            otriggerCh1->redraw();
            btrigger1 = 1;
            isec_trigger = 1;
            ogroupPos->box(FL_UP_BOX);
            ogroupDual->box(FL_UP_BOX);
            otiempoDiv->value(8);
            omenuTdiv->value(8);
            canal1->ovoltDiv->value(0);
            canal1->omenuvDiv->value(0);
            canal1->oacopAc->color(FL_RED);
            canal1->oacopAc->redraw();
            strcpy(odispOsc1->ctrigger,"Trg-Ch1");
            strcpy(odispOsc1->cacople,"AC");
            strcpy(odispOsc1->ccanal,"Ch1");
            strcpy(odispOsc1->ct_div,"1mS/Dv");
            strcpy(odispOsc1->cv_div,"5V/Dv");
            odispOsc1->redraw();
            isec_acople=1;
            opantalla->bch1 = 1;
            muestreoTimer(1);                                   //Muestrear por vectores deacuerdo a la escala de tiempo por división.
         }                                                       
         else {                                                  //Si la respuesta fue NAK o error en la comunicación USB
              fl_message("Error de conexión de hardware");                   
              ooscOn->value(0);                                 //Osciloscopio desactivado
              ooscOn->box(FL_UP_BOX);                           //Restablecer el botón para un nuevo intento
         }  
      }
      ooscOn->box(FL_DOWN_BOX);
      if (ooscOn->value()== 0){                                 //Presionar el botón para apagar el instrumento
         Fl::remove_timeout(cbTimer, this);                     //Terminar el timer de solicitud de datos uno a uno 
         Fl::remove_timeout(cbTimerVectores, this);            //Terminar el timer de solicitud de datos por vectores
         ogroupTdiv->box(FL_ENGRAVED_BOX);
         ogroupTrigger->box(FL_ENGRAVED_BOX);
         ogroupPos->box(FL_ENGRAVED_BOX);
         ogroupDual->box(FL_ENGRAVED_BOX);
         oayudaOsc->value(0);
         Encapsular('A','b','1','0',0x00,0x00);                  //Trama para apagar el canal 1
         opantalla->bch1 = 0;
         Transmision();
         if (bhardware){
            och1On->value(0);
            canal1->activar(0);
            canal1->~Canal();
            canal1->ogroupCh->box(FL_ENGRAVED_BOX);
            canal1->ogroupCh->deactivate();
         }
         else {
             fl_message("Error de hardware");                    
         }
         Encapsular('B','b','1','0',0x00,0x00);                  //Trama para apagar el canal 2
         opantalla->bch2 = 0;
         Transmision();
         if (bhardware){
           och2On->value(0);
           canal2->activar(0);
           canal2->~Canal();
           canal2->ogroupCh->box(FL_ENGRAVED_BOX);
           canal2->ogroupCh->deactivate();
           odualMenu->deactivate();
         }
         else {
             fl_message("Error de hardware");
         }
         activar(0);
         opantalla->bch2 = 0;
         opantalla->bch1 = 0;
         opantalla->TraceColour(FL_BLACK);
         ogroupOsc->deactivate(); 
         ogroupTdiv->deactivate();
         odualMenu->deactivate();
         isec_trigger = 0;
         otriggerCh1->color(FL_GRAY);
         otriggerCh1->redraw();
         btrigger1 = 0;
         otriggerCh2->color(FL_GRAY);
         otriggerCh2->redraw();
         btrigger2 = 0;         
         isec_acople = 0;          
         isec_acople2 = 0;
         isec_dual = -1;
         bsuma = 0;
         bresta = 0;
         bx_y = 0;
         osuma->color(FL_GRAY);
         osuma->redraw();
         oresta->color(FL_GRAY);
         oresta->redraw();
         oxy->color(FL_GRAY);
         osuma->redraw();
         canal1->oacopAc->color(FL_GRAY);
         canal1->oacopAc->redraw();
         canal1->oacopDc->color(FL_GRAY);
         canal1->oacopDc->redraw();
         canal1->oacopGnd->color(FL_GRAY);
         canal1->oacopGnd->redraw();
         canal2->oacopAc->color(FL_GRAY);
         canal2->oacopAc->redraw();
         canal2->oacopDc->color(FL_GRAY);
         canal2->oacopDc->redraw();
         canal2->oacopGnd->color(FL_GRAY);
         canal2->oacopGnd->redraw();
         strcpy(odispOsc1->ctrigger,"       ");
         strcpy(odispOsc1->cacople,"  ");
         strcpy(odispOsc1->ccanal,"   ");
         strcpy(odispOsc1->ct_div,"      ");
         strcpy(odispOsc1->cv_div,"     ");
         odispOsc1->redraw();
         strcpy(odispOsc2->ctrigger,"       ");
         strcpy(odispOsc2->cacople,"  ");
         strcpy(odispOsc2->ccanal,"   ");
         strcpy(odispOsc2->ct_div,"      ");
         strcpy(odispOsc2->cv_div,"     ");
         odispOsc2->redraw();
         bacopleGnd1 = 0;
         bacopleGnd2 = 0;
         opantalla->bdual = 0;
         opantalla->blissajous = 0;
         ooscOn->box(FL_UP_BOX);
      }
}


/*******************************************************************************
* Osciloscopio::cbGrilla: Callback del botón para activar o desactivar la 
*                          cuadricula que permite realizar las mediciones en la 
*                          pantalla del osciloscopio.
* El Callaback consta de la función static e inline cbGrilla y cbGrillaIn.
* ogrilla->bgrid = 1 : Activa la cuadricula de 10 x 8 
* ogrilla->bgrid = 0 : Desactiva la grilla de 10 x 8 y deja solo los ejes que 
*                      dividen en 4 la pantalla. 
*******************************************************************************/

void Osciloscopio::cbGrilla(Fl_Widget* pboton, void *pany){
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbGrillaIn();
}

void Osciloscopio::cbGrillaIn(){
     if (ogrillaOn->value()==1){
        ogrilla->bgrid = 1;
     }
     else{
         ogrilla->bgrid = 0; 
     }
     ogrilla->redraw();
}

/*******************************************************************************
* Osciloscopio::cbStop: Callback del botón para detener las gráficas en la 
*                        pantalla del osciloscopio.
* El Callaback consta de la función static e inline cbStop y cbStopIn.
* Si el botón esta presionado no se hace llamado a la función recorrerDatos()
* es decir no se envían datos para ser graficados.
*******************************************************************************/

void Osciloscopio::cbStop(Fl_Widget* pboton, void *pany){
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbStopIn();
}

void Osciloscopio::cbStopIn(){
     if (ostop->value()==1){
        ostop->box(FL_DOWN_BOX);
     }
     else{
         ostop->box(FL_UP_BOX);
     }
}

/*******************************************************************************
* Osciloscopio::cbCh1On: Callback del botón para encender o apagar el canal 1 
*                          del osciloscopio. 
* El Callaback consta de la función static e inline cbCh1On y cbCh1OnIn.
* Para activar el canal se deben detener los timers de solicitud de muestras al
* hardware que esten activos para reiniciar nuevamente sincronizados de acuerdo
* con la escala de tiempo por divisíon que el usuario haya seleccionado.
* Se activan los controles propios del canal y si el canal 2 se encuentra activo
* se activan las operaciones entre las dos señales.  
*******************************************************************************/

void Osciloscopio::cbCh1On(Fl_Widget* pboton, void *pany){
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbCh1OnIn();
}

void Osciloscopio::cbCh1OnIn(){
    if (och1On->value()== 1){
        Fl::remove_timeout(cbTimer,this);                        //Detener el timer de solicitud de datos uno a uno
        Fl::remove_timeout(cbTimerVectores,this);               //Detener el timer de solicitud de datos por vectores
        Encapsular('A','a','1','0',0x00,0x00);                    //Activar canal 1 en el hardware
        Transmision();
        if (bhardware){
           canal1->activar(1);
           canal1->ogroupCh->activate();
           canal1->ogroupCh->box(FL_UP_BOX);
           opantalla->bch1 = 1;
           strcpy(odispOsc1->cacople,"AC");
           strcpy(odispOsc1->ccanal,"Ch1");
           odispOsc1->redraw();
           if (canal2->bestado== 1){                              //Si el canal 2 ya está activo se habilitan las operaciones entre las dos señales
              odualMenu->activate();
           }
           if (otiempoDiv->value() >= 8){                         // !!!! Toca cambiarlo a >= 2 
           //if (otiempoDiv->value() >= 3){                       // !!!! Toca cambiarlo a >= 2 
              Encapsular('L','d','1',ctDiv,0x00,0x00);            // Configurar escala de Tiempo por division muestreo por vectores 
              Transmision();
              if (bhardware){
                 muestreoTimer(1);                                //Solicitar al hardware muestras por vectores
              }
              else{
                   fl_message("Error de hardware");
              }
           }
           else {
                Encapsular('L','d','1','B',0x00,0x00);            //Configurar escala de Tiempo por division muestreo por vectores 
                //Encapsular('L','d','1','F',0x00,0x00);            //Configurar escala de Tiempo por division muestreo por vectores 
                Transmision();
                if (bhardware){
                   muestreoTimer(2);                             //Solicitar al hardware muestras una a una.
                }
                else{
                   fl_message("Error de hardware");
                }
           }
        }
        else {
             fl_message("Error de hardware");
        }    
     }
     else{
        if (canal2->bestado== 0){ 
           Fl::remove_timeout(cbTimer,this);
           Fl::remove_timeout(cbTimerVectores,this);
        }
        else {
             bsuma = 0;
             osuma->color(FL_GRAY);
             osuma->redraw();
             bresta = 0;
             oresta->color(FL_GRAY);
             oresta->redraw();
             bx_y = 0;
             oxy->color(FL_GRAY);
             oxy->redraw();
             isec_dual=3;
             cbDualMenuIn();
        }
        Encapsular('A','b','1','0',0x00,0x00);                         //Desactivar canal 1 en hardware
        opantalla->bch1 = 0;
        Transmision();
        if (bhardware){
           canal1->activar(0);
           canal1->ogroupCh->box(FL_ENGRAVED_BOX);
           canal1->ogroupCh->deactivate();
           odualMenu->deactivate();
        }
        else {
             fl_message("Error de hardware");
        }   
     }
}


/*******************************************************************************
* Osciloscopio::cbCh2On: Callback del botón para encender o apagar el canal 2 
*                          del osciloscopio. 
* El Callaback consta de la función static e inline cbCh2On y cbCh2OnIn.
* Para activar el canal se deben detener los timers de solicitud de muestras al
* hardware que esten activos para reiniciar nuevamente sincronizados de acuerdo
* con la escala de tiempo por divisíon que el usuario haya seleccionado.
* Se activan los controles propios del canal y si el canal 1 se encuentra activo
* se activan las operaciones entre las dos señales.  
*******************************************************************************/

void Osciloscopio::cbCh2On(Fl_Widget* pboton, void *pany){
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbCh2OnIn();
}

void Osciloscopio::cbCh2OnIn(){
     if (och2On->value()== 1){               
        Fl::remove_timeout(cbTimer,this);
        Fl::remove_timeout(cbTimerVectores,this);
        Encapsular('B','a','1','0',0x00,0x00);                      //Activar canal 2 en hardware
        Transmision();
        if (bhardware){
           canal2->activar(1);
           canal2->ogroupCh->activate();
           canal2->ogroupCh->box(FL_UP_BOX);
           canal2->oacopAc->color(FL_RED);
           canal2->oacopAc->redraw();
           isec_acople2 = 1;
           canal2->ovoltDiv->value(0);
           canal2->omenuvDiv->value(0);
           opantalla->bch2 = 1;
           strcpy(odispOsc2->cacople,"AC");
           strcpy(odispOsc2->ccanal,"Ch2");
           strcpy(odispOsc2->cv_div,"5V/Dv");
           odispOsc2->redraw();
           if (canal1->bestado== 1){
              odualMenu->activate();                               //Si el canal 1 está activo se habilitan las operaciones entre las dos señales 
           }
           if (otiempoDiv->value() >= 8){                          // !!!!  Toca cambiarlo a >= 2  
           //if (otiempoDiv->value() >= 3){                        // !!!! Toca cambiarlo a >= 2
              Encapsular('L','d','1',ctDiv,0x00,0x00);            //Configurar escala de Tiempo por division muestreo por vectores 
              Transmision();
              if (bhardware){
                 muestreoTimer(1);                                 //Solicitar al hardware muestras por vectores
              }
              else{
                   fl_message("Error de hardware");
              }
           }
           else {
                Fl::remove_timeout(cbTimer,this);
                Fl::remove_timeout(cbTimerVectores,this);
                Encapsular('L','d','1','B',0x00,0x00);            //Configurar escala de Tiempo por division muestreo por vectores 
                //Encapsular('L','d','1','F',0x00,0x00);            //Configurar escala de Tiempo por division muestreo por vectores
                Transmision();
                if (bhardware){
                   muestreoTimer(2);                             //Solicitar al hardware muestras una a una
                }
                else{
                   fl_message("Error de hardware");
                }
           }
        }
        else {
             fl_message("Error de hardware");
        }
     }
     else{
        if (canal1->bestado == 0){
           Fl::remove_timeout(cbTimer,this);
           Fl::remove_timeout(cbTimerVectores,this);
        }
        else {
             bsuma = 0;
             osuma->color(FL_GRAY);
             osuma->redraw();
             bresta = 0;
             oresta->color(FL_GRAY);
             oresta->redraw();
             bx_y = 0;
             oxy->color(FL_GRAY);
             oxy->redraw();
             isec_dual=3;
             cbDualMenuIn();
        }
        Encapsular('B','b','1','0',0x00,0x00);                      //Desactivar canal 2 por hardware
        opantalla->bch2 = 0;
        Transmision();
        if (bhardware){
           canal2->activar(0);
           canal2->ogroupCh->box(FL_ENGRAVED_BOX);
           canal2->ogroupCh->deactivate();
           odualMenu->deactivate();
        }
        else {
             fl_message("Error de hardware");
        } 
     }
}


/*******************************************************************************
* Osciloscopio::cbDualMenu: Callback del botón del menú de las funciones duales 
*                             entre gráficas en el osciloscopio.
* El Callaback consta de la función static e inline cbDualMenu y cbDualMenuIn.
* Esta secuencia se activa solo si los dos canales están activos.
* Al presionar el botón "dual" se selecciona una de las 3 operaciones entre las
* dos señales: Suma, Resta o X vs Y.
* isec_dual: Variable tipo entero que representa la operación dual solicitada por
*            el usuario.
* isec_dual = 0: Operación de suma entre las señales de los dos canales;
*                se representa en la pantalla canal1 + canal2.
* isec_dual = 1: Operación de Resta entre las señales de los dos canales;
*                se representa en la pantalla canal1 - canal2.
* isec_dual = 3: Operación de X vs Y entre las señales de los dos canales;
*                se representa en la pantalla canal1 vs canal2, si las señales
*                son periodicas, se grafica la figura de lissajous resultante.
*******************************************************************************/

void Osciloscopio::cbDualMenu(Fl_Widget* pboton, void *pany){
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbDualMenuIn();
}

void Osciloscopio::cbDualMenuIn(){
     if (isec_dual==0){                                        //Activar función de gráfica canal1 + canal2
        oxy->color(FL_GRAY);
        oxy->redraw();
        bx_y = 0;                                              
        bsuma = 1;                                             
        osuma->color(FL_RED);
        osuma->redraw();
        opantalla->bdual = 1;
     }
     if (isec_dual==1){                                        //Activar función de gráfica canal1 - canal2
        bsuma = 0;
        bresta = 1;
        osuma->color(FL_GRAY);
        osuma->redraw();
        oresta->color(FL_RED);
        oresta->redraw();
        opantalla->bdual = 1;
     }
     if (isec_dual==2){                                        //Activar función de gráfica canal1 vs canal2
        oresta->color(FL_GRAY);
        oresta->redraw();
        bresta = 0;
        bx_y = 1;
        oxy->color(FL_RED);
        oxy->redraw();
        opantalla->bdual = 1;
        opantalla->blissajous = 1;
     }
     if (isec_dual==3){                                        //Activar gráfica canal1 y canal2 sin operaciones
        oxy->color(FL_GRAY);
        oxy->redraw();
        bx_y = 0;
        opantalla->bdual = 0;
        opantalla->blissajous = 0;
        isec_dual=-1;
     }
     isec_dual++;
}

/*******************************************************************************
 * Osciloscopio::cbSelTrigger: Callback del botón selector del canal fuente del 
 *                               disparo (trigger) en el osciloscopio.  
 * El Callaback consta de la función static e inline cbSelTrigger y 
 * cbSelTriggerIn.
 * Al presionar el boton "Trigger" se selecciona el canal en el cual se compara
 * el nivel del trigger ajustado por el usuario para iniciar el almacenamiento 
 * de datos.  
 * isec_trigger: Variable que representa la opción del canal fuente de trigger
 *               seleccionado por el usuario.
 * isec_trigger = 0: Canal 1 fuente del disparo.
 * isec_trigger = 1: Canal 2 fuente del disparo.
*******************************************************************************/

void Osciloscopio::cbSelTrigger(Fl_Widget* pboton, void *pany){
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbSelTriggerIn();
}

void Osciloscopio::cbSelTriggerIn(){
     if (isec_trigger==0){
        otriggerCh2->color(FL_GRAY);
        otriggerCh2->redraw();
        otriggerCh1->color(FL_RED);
        otriggerCh1->redraw();
        strcpy(odispOsc1->ctrigger,"Trg-Ch1");
        odispOsc1->redraw();
        /* TODO (JuanPablo#1#): Encapsular trama de canal fuente de trigger */
     }
     if (isec_trigger==1){
        otriggerCh1->color(FL_GRAY);
        otriggerCh1->redraw();
        otriggerCh2->color(FL_RED);
        otriggerCh2->redraw();
        strcpy(odispOsc1->ctrigger,"Trg-Ch2");
        odispOsc1->redraw();
        isec_trigger=-1;
     }
     isec_trigger++;
}

/*******************************************************************************
 * cbTiempoDiv: Callback del selector de escala de tiempo por división en el 
 *                osciloscopio. 
 * El Callaback consta de la función static e inline cbTiempoDiv y 
 * cbTiempoDivIn.
 * El selector "T_Div" controla las 18 opciones de escala de tiempo por división
 * que modifican la frecuencia de muestreo en el hardware.
 * Las opciones 0 y 1 son para frecuencias de muestreo muy bajas y se solicitan 
 * las muestras una a una desde el software. 
 * Las opciones de la 2 a la 17 solicitan al hardware el cambio en la frecuencia 
 * de muestreo, el almacenamiento de las muestras en la memoria y luego solicita
 * las muestras en 4 vectores de 147 datos. 
*******************************************************************************/

void Osciloscopio::cbTiempoDiv(Fl_Widget* psel, void *pany){
     Fl_Knob *pselector = (Fl_Knob *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbTiempoDivIn(pselector);
}

void Osciloscopio::cbTiempoDivIn(Fl_Widget* psel){
     Fl_Knob *pselector = (Fl_Knob *)psel;
     omenuTdiv->value(pselector->value());
     if (pselector->value()>=8){                                   // !!!!! Toca cambiarlo a >= 2 
    // if (pselector->value()>=3){                                   // !!!!! Toca cambiarlo a >= 2 
       /*                                                            // !!! agregar las tramas de protocolo faltantes 
       if (pselector->value()== 3){
           ctDiv = 'E';  
           strcpy(odispOsc1->ct_div,"50mS/Dv");
           odispOsc1->redraw();                                   
        } 
        else if (pselector->value() == 4){
            ctDiv = 'D';
            strcpy(odispOsc1->ct_div,"20mS/Dv");
            odispOsc1->redraw();                                    
        } 
        else if (pselector->value() == 5){
            ctDiv = 'C';
            strcpy(odispOsc1->ct_div,"10mS/Dv");
            odispOsc1->redraw();                                   
        } 
        else if (pselector->value() == 6){
            ctDiv = 'B';
            strcpy(odispOsc1->ct_div,"5mS/Dv");
            odispOsc1->redraw();                                    
        } 
        else if (pselector->value() == 7){
            ctDiv = 'A';
            strcpy(odispOsc1->ct_div,"2mS/Dv");
            odispOsc1->redraw();                                     
        } 
        else if (pselector->value() == 8){
            ctDiv = '9';
            strcpy(odispOsc1->ct_div,"1mS/Dv");
            odispOsc1->redraw();                                    
        }   
        else if (pselector->value() == 9){
            ctDiv = '8';
            strcpy(odispOsc1->ct_div,"0.5mS/Dv");
            odispOsc1->redraw();                                    
        }
        else if (pselector->value() == 10){
            ctDiv = '7';  
            strcpy(odispOsc1->ct_div,"0.2mS/Dv");
            odispOsc1->redraw();                                  
        }
        else if (pselector->value() == 11){
            ctDiv = '6';
            strcpy(odispOsc1->ct_div,"0.1mS/Dv");
            odispOsc1->redraw();                                    
        }
        else if (pselector->value() == 12){
            ctDiv = '5';
            strcpy(odispOsc1->ct_div,"50uS/Dv");
            odispOsc1->redraw();                                     
        }
        else if (pselector->value() == 13){
            ctDiv = '4';
            strcpy(odispOsc1->ct_div,"20uS/Dv");
            odispOsc1->redraw();                                     
        }
        else if (pselector->value() == 14){
            ctDiv = '3';
            strcpy(odispOsc1->ct_div,"10uS/Dv");
            odispOsc1->redraw();                                     
        }
        else if (pselector->value() == 15){
            ctDiv = '2';
            strcpy(odispOsc1->ct_div,"5uS/Dv");
            odispOsc1->redraw();                                     
        }
        else if (pselector->value() == 16){
            ctDiv = '1';
            strcpy(odispOsc1->ct_div,"2uS/Dv");
            odispOsc1->redraw();                                     
        }
        else if (pselector->value() == 17){
            ctDiv = '0';
            strcpy(odispOsc1->ct_div,"1uS/Dv");
            odispOsc1->redraw();                                     
        }
        */  
     
        if (pselector->value()== 8){
           ctDiv = '1'; 
           strcpy(odispOsc1->ct_div,"1mS/Dv");
           odispOsc1->redraw();                                    
        } 
        else if (pselector->value() == 9){
            ctDiv = '2';
            strcpy(odispOsc1->ct_div,"0.5mS/Dv");
            odispOsc1->redraw();                                   
        } 
        else if (pselector->value() == 10){
            ctDiv = '3';
            strcpy(odispOsc1->ct_div,"0.2mS/Dv");
            odispOsc1->redraw();                                   
        } 
        else if (pselector->value() == 11){
            ctDiv = '4'; 
            strcpy(odispOsc1->ct_div,"0.1mS/Dv");
            odispOsc1->redraw();                                 
        } 
        else if (pselector->value() == 12){
            ctDiv = '5'; 
            strcpy(odispOsc1->ct_div,"50uS/Dv");
            odispOsc1->redraw();                    
        } 
        else if (pselector->value() == 13){
            ctDiv = '6'; 
            strcpy(odispOsc1->ct_div,"20uS/Dv");
            odispOsc1->redraw();                          
        }   
        else if (pselector->value() == 14){
            ctDiv = '7';   
            strcpy(odispOsc1->ct_div,"10uS/Dv");
            odispOsc1->redraw();                  
        }
        else if (pselector->value() == 15){
            ctDiv = '8'; 
            strcpy(odispOsc1->ct_div,"5uS/Dv");
            odispOsc1->redraw();                     
        }
        else if (pselector->value() == 16){
            ctDiv = '9';
            strcpy(odispOsc1->ct_div,"2uS/Dv");
            odispOsc1->redraw();                     
        }
        else if (pselector->value() == 17){
            ctDiv = 'A';
            strcpy(odispOsc1->ct_div,"1uS/Dv");
            odispOsc1->redraw();                                   
        } 
        Encapsular('L','d','1',ctDiv,0x00,0x00);                       //Trama de configuración de escala de Tiempo por division menor de 0.1s
        Fl::remove_timeout(cbTimer,this);
        Fl::remove_timeout(cbTimerVectores,this); 
        Transmision();
        if (bhardware){
           muestreoTimer(1);                                           //Solicitar envío de muestras en vectores 
        }
        else
             fl_message("Error de hardware");
     }
     else {
          Encapsular('L','d','1','B',0x00,0x00);                        // !!!!!cambiar 'B' por 'F' //Trama de configuración de escala de Tiempo por division mayor de 0.1s
          //Encapsular('L','d','1','F',0x00,0x00);                        // !!!!!cambiar 'B' por 'F' //Trama de configuración de escala de Tiempo por division mayor de 0.1s
          Fl::remove_timeout(cbTimer,this);
          Fl::remove_timeout(cbTimerVectores,this);                
          Transmision();
          if (bhardware)
             muestreoTimer(2);                                         //Solicitar envío de muestras en una a una
     }
}

/*******************************************************************************
 * Osciloscopio::cbVoltDiv1: Callback del selector de la escala de volt/div
 *                             del canal 1 del osciloscopio.
 * El Callaback consta de la función static e inline cbVoltDiv1 y cbVoltDiv1In.
 * El selector "V_Div" del canal 1 controla las 12 opciones de escala de 
 * atenuación o amplificación de la señal sensada con el canal 1 del osciloscopio
 * con las cuales se va a visualizar la señal en la pantalla. 
 * Las opciones se envían en tramas del protocolo como caracteres hexadecimales
 * desde el '0' hasta 'C'.
*******************************************************************************/
void Osciloscopio::cbVoltDiv1(Fl_Widget* psel, void *pany){
     Fl_Knob *pselector = (Fl_Knob *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;          
     posc->cbVoltDiv1In(pselector);
}


void Osciloscopio::cbVoltDiv1In(Fl_Widget* psel){
     Fl_Knob *pselector = (Fl_Knob *)psel;           
     canal1->omenuvDiv->value(pselector->value());                    
     if (int((pselector->value()))== 9){
         Encapsular('A','c','1','A',0x00,0x00);                             //Trama con la configuración seleccionada por el usuario
         Transmision();
         strcpy(odispOsc1->cv_div,"5mV/Dv");
         odispOsc1->redraw();
     }
     else if (int((pselector->value()))== 10){
        Encapsular('A','c','1','B',0x00,0x00);
         Transmision();
         strcpy(odispOsc1->cv_div,"2mV/Dv");
         odispOsc1->redraw();
     }
     else if (int((pselector->value()))== 11){
         Encapsular('A','c','1','C',0x00,0x00);
         Transmision();
         strcpy(odispOsc1->cv_div,"1mV/Dv");
         odispOsc1->redraw();               
     }
     else if (int((pselector->value()))== 0){
         Encapsular('A','c','1','1',0x00,0x00);
         Transmision();
         strcpy(odispOsc1->cv_div,"5V/Dv");
         odispOsc1->redraw();                    
     }
     else if (int((pselector->value()))== 1){
         Encapsular('A','c','1','2',0x00,0x00);
         Transmision();
         strcpy(odispOsc1->cv_div,"2V/Dv");
         odispOsc1->redraw();                            
     }
     else if (int((pselector->value()))== 2){
         Encapsular('A','c','1','3',0x00,0x00);
         Transmision(); 
         strcpy(odispOsc1->cv_div,"1V/Dv");
         odispOsc1->redraw();             
     }
     else if (int((pselector->value()))== 3){
         Encapsular('A','c','1','4',0x00,0x00);
         Transmision();
         strcpy(odispOsc1->cv_div,"0.5V/Dv");
         odispOsc1->redraw();              
     }
     else if (int((pselector->value()))== 4){
         Encapsular('A','c','1','5',0x00,0x00);
         Transmision();
         strcpy(odispOsc1->cv_div,"0.2V/Dv");
         odispOsc1->redraw();                          
     }
     else if (int((pselector->value()))== 5){
         Encapsular('A','c','1','6',0x00,0x00);
         Transmision();
         strcpy(odispOsc1->cv_div,"0.1V/Dv");
         odispOsc1->redraw();                           
     }
     else if (int((pselector->value()))== 6){
         Encapsular('A','c','1','7',0x00,0x00);
         Transmision();
         strcpy(odispOsc1->cv_div,"50mV/Dv");
         odispOsc1->redraw();                           
     }
     else if (int((pselector->value()))== 7){
         Encapsular('A','c','1','8',0x00,0x00);
         Transmision();
         strcpy(odispOsc1->cv_div,"20mV/Dv");
         odispOsc1->redraw();                           
     }
     else if (int((pselector->value()))== 8){
         Encapsular('A','c','1','9',0x00,0x00);
         Transmision();
         strcpy(odispOsc1->cv_div,"10mV/Dv");
         odispOsc1->redraw();              
     }
}


/*******************************************************************************
 * Osciloscopio::cb_volt_div2: Callback del selector de la escala de volt/div
 *                             del canal 2 del osciloscopio.
 * El Callaback consta de la función static e inline cb_volt_div2 y 
 * cb_volt_div2_in.
 * El selector "V_Div" del canal 2 controla las 12 opciones de escala de 
 * atenuación o amplificación de la señal sensada con el canal 2 del osciloscopio
 * con las cuales se va a visualizar la señal en la pantalla. 
 * Las opciones se envían en tramas del protocolo como caracteres hexadecimales
 * desde el '0' hasta 'C'.
*******************************************************************************/
void Osciloscopio::cb_volt_div2(Fl_Widget* psel, void *pany){
     Fl_Knob *pselector = (Fl_Knob *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;          
     posc->cb_volt_div2_in(pselector);
}
  
void Osciloscopio::cb_volt_div2_in(Fl_Widget* psel){
     Fl_Knob *pselector = (Fl_Knob *)psel;              
     canal2->omenuvDiv->value(pselector->value());                 
     if (int((pselector->value()))== 9){
         Encapsular('B','c','1','A',0x00,0x00);
         Transmision(); 
         strcpy(odispOsc2->cv_div,"5mV/Dv");
         odispOsc2->redraw();
     }
     else if (int((pselector->value()))== 10){
        Encapsular('B','c','1','B',0x00,0x00);
         Transmision();
         strcpy(odispOsc2->cv_div,"2mV/Dv");
         odispOsc2->redraw(); 
     }
     else if (int((pselector->value()))== 11){
         Encapsular('B','c','1','C',0x00,0x00);
         Transmision();
         strcpy(odispOsc2->cv_div,"1mV/Dv");
         odispOsc2->redraw();                     
     }
     else if (int((pselector->value()))== 0){
         Encapsular('B','c','1','1',0x00,0x00);
         Transmision(); 
         strcpy(odispOsc2->cv_div,"5V/Dv");
         odispOsc2->redraw();                           
     }
     else if (int((pselector->value()))== 1){
         Encapsular('B','c','1','2',0x00,0x00);
         Transmision();
         strcpy(odispOsc2->cv_div,"2V/Dv");
         odispOsc2->redraw();                          
     }
     else if (int((pselector->value()))== 2){
         Encapsular('B','c','1','3',0x00,0x00);
         Transmision();
         strcpy(odispOsc2->cv_div,"1V/Dv");
         odispOsc2->redraw();              
     }
     else if (int((pselector->value()))== 3){
         Encapsular('B','c','1','4',0x00,0x00);
         Transmision();  
         strcpy(odispOsc2->cv_div,"0.5V/Dv");
         odispOsc2->redraw();                    
     }
     else if (int((pselector->value()))== 4){
         Encapsular('B','c','1','5',0x00,0x00);
         Transmision(); 
         strcpy(odispOsc2->cv_div,"0.2V/Dv");
         odispOsc2->redraw();            
     }
     else if (int((pselector->value()))== 5){
         Encapsular('B','c','1','6',0x00,0x00);
         Transmision(); 
         strcpy(odispOsc2->cv_div,"0.1V/Dv");
         odispOsc2->redraw();            
     }
     else if (int((pselector->value()))== 6){
         Encapsular('B','c','1','7',0x00,0x00);
         Transmision(); 
         strcpy(odispOsc2->cv_div,"50mV/Dv");
         odispOsc2->redraw();            
     }
     else if (int((pselector->value()))== 7){
         Encapsular('B','c','1','8',0x00,0x00);
         Transmision();
         strcpy(odispOsc2->cv_div,"20mV/Dv");
         odispOsc2->redraw();                            
     }
     else if (int((pselector->value()))== 8){
         Encapsular('B','c','1','9',0x00,0x00);
         Transmision();
         strcpy(odispOsc2->cv_div,"10mV/Dv");
         odispOsc2->redraw();                            
     }
}


/*******************************************************************************
 * Osciloscopio::cbPosy: Callback de la perilla que configura la posición 
 *                       horizontal de la gráfica de la señal. 
 * El Callaback consta de la función static e inline cbPosy y cbPosyIn.
 * El valor que el usuario configura con la perilla "Pos_x" se envía al objeto
 * opantalla y se le suma al punto de inicio de la gráfica en la pantalla para
 * generar el desplazamiento horizontal. 
 * Luego de la modificación se debe redibujar tanto las gráficas como la grilla
 * si está activa y los mensajes con la información de los canales. 
*******************************************************************************/

void Osciloscopio::cbPosy(Fl_Widget* psel, void *pany){
     Fl_Knob *pselector = (Fl_Knob *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbPosyIn(pselector);
}

void Osciloscopio::cbPosyIn(Fl_Widget* psel){
     Fl_Knob *pselector = (Fl_Knob *)psel;
     pselector->value(floor(pselector->value()));
     opantalla->ipos_x =  int(pselector->value());
     ogrilla->redraw(); 
     opantalla->redraw(); 
     odispOsc1->redraw();
     odispOsc2->redraw(); 
}

/*******************************************************************************
 * Osciloscopio::cbTimer: Callback del timer para realizar la solicitud de 
 *                         datos muestreados uno a uno.
 * El Callaback consta de la función static e inline cbTimer y cbTimerIn.
 * Cada vez que ocurre el timer se envía la trama de solicitud de muestra, luego 
 * el dato se envía para ser graficado; la repetición del timer se realiza 
 * deacuerdo a la escala de tiempo por división que se haya seleccionado. 
*******************************************************************************/

void Osciloscopio::cbTimer(void *pany){
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbTimerIn();
}

void Osciloscopio::cbTimerIn(){
     Encapsular('L','y','1','0',0x00,0x00);                               //Trama de solicitud al hardware de una muestra de la señal en los canales activos      
     Transmision();
     if (canal1->bestado && canal2->bestado){                             //Ambos canales activos 
        recorrerDatos(3);
     }
     else if (canal1->bestado== 1 && canal2->bestado== 0){
          recorrerDatos(1);
     }
     else if (canal1->bestado== 0 && canal2->bestado== 1){
          recorrerDatos(2);
     }
     if(otiempoDiv->value()== 0){
        Fl::repeat_timeout(0.5, cbTimer, this);                          //Repetición del timer.
     }
     if(otiempoDiv->value()== 1){
        Fl::repeat_timeout(0.2, cbTimer, this);
     }
     if(otiempoDiv->value()== 2){
        Fl::repeat_timeout(0.1, cbTimer, this);
     }
     // Se quitan los siguientes por el cambio.
     if(otiempoDiv->value()== 3){
        Fl::repeat_timeout(0.05, cbTimer, this);
     }
     if(otiempoDiv->value()== 4){
        Fl::repeat_timeout(0.02, cbTimer, this);
     }
     if(otiempoDiv->value()== 5){
        Fl::repeat_timeout(0.01, cbTimer, this);
     }
     if(otiempoDiv->value()== 6){
        Fl::repeat_timeout(0.005, cbTimer, this);
     }
     if(otiempoDiv->value()== 7){
        Fl::repeat_timeout(0.002, cbTimer, this);
     }
}


/*******************************************************************************
 * Osciloscopio::cbTimerVectores: Callback del timer para realizar la solicitud 
 *                                  de muestras por vectores de datos.  
 * El Callaback consta de la función static e inline cbTimerVectores y 
 * cbTimerVectoresIn.
 * Con la trama Osc14 se le ordena al hardware que muestree las señales en 
 * el(los) canal(es) activos a la frecuencia de muestreo que esté configurada.
 * Cuando el hardware haya terminado de adquirir las muestras se solicitan los
 * cuatro vectores de 147 datos de los canales activos con la trama Osc16.
 * Si está presionado el botón de detención de la gráfica, no se envian los
 * datos para ser graficados.
*******************************************************************************/
void Osciloscopio::cbTimerVectores(void *pany){
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbTimerVectoresIn();
}

void Osciloscopio::cbTimerVectoresIn(){
     if (canal1->bestado == 1 && canal2->bestado==0){
        Encapsular('L', 'p', '1', '0',0x00,0x00);                //Trama Osc14   
        Transmision();
        if (ch1_muestreado){                                     //El hardware termino de adquirir las muetras del canal 1
           Encapsular('A', 'p', '1', '1',0x00,0x00);             //Trama Osc16 
           Transmision();
           Encapsular('A', 'p', '1', '2',0x00,0x00);             
           Transmision();
           Encapsular('A', 'p', '1', '3',0x00,0x00);             
           Transmision();
           Encapsular('A', 'p', '1', '4',0x00,0x00);             
           Transmision();
           if (ostop->value() == 0)                              // Si está presionado el botón de stop, no se envian los datos para ser graficado
              recorrerDatos(1);
        }
     }
     if (canal2->bestado==1 && canal1->bestado==0){
        Encapsular('L', 'p', '1', '0',0x00,0x00);
        Transmision();
        if (ch2_muestreado){                                     //El hardware termino de adquirir las muetras del canal 2
           Encapsular('B', 'p', '1', '1',0x00,0x00);             //Trama Osc16
           Transmision();
           Encapsular('B', 'p', '1', '2',0x00,0x00);
           Transmision();
           Encapsular('B', 'p', '1', '3',0x00,0x00);
           Transmision();
           Encapsular('B', 'p', '1', '4',0x00,0x00);
           Transmision();
           if (ostop->value() == 0)
              recorrerDatos(2);
        }
     }
     if (canal1->bestado==1 && canal2->bestado==1){                    
        Encapsular('L', 'p', '1', '0',0x00,0x00);
        Transmision();
        if (ch1_muestreado && ch2_muestreado){                   //El hardware termino de adquirir las muetras de los 2 canales
           Encapsular('A', 'p', '1', '1',0x00,0x00);             //Trama Osc16
           Transmision();
           Encapsular('A', 'p', '1', '2',0x00,0x00);
           Transmision();
           Encapsular('A', 'p', '1', '3',0x00,0x00);
           Transmision();
           Encapsular('A', 'p', '1', '4',0x00,0x00);
           Transmision();
           Encapsular('B', 'p', '1', '1',0x00,0x00);
           Transmision();
           Encapsular('B', 'p', '1', '2',0x00,0x00);
           Transmision();
           Encapsular('B', 'p', '1', '3',0x00,0x00);
           Transmision();
           Encapsular('B', 'p', '1', '4',0x00,0x00);
           Transmision();
           if (ostop->value() == 0)
              recorrerDatos(3);
        }
     }
    Fl::repeat_timeout(0.09, cbTimerVectores, this);           //Repetición del timer
}



/*******************************************************************************
 * Osciloscopio::recorrerDatos: Rutina que recorre el arreglo buf_osc_chx que
 *                               contiene las muestras de la señal y envía los 
 *                               datos al objeto opantalla para generar la 
 *                               gráfica de las señales. 
 * num_canal: Variable argumento que indica que canal(es) se debe(n) gráficar.                              
 * num_canal = 1: Enviar los datos para graficar la señal del canal 1.
 * num_canal = 2: Enviar los datos para graficar la señal del canal 2.
 * num_canal = 3: Enviar los datos para graficar las señales de los dos canales.
 * bsuma: Variable que indica que se ha seleccionado la operación de suma de las
 *        dos señales.
 * bresta: Variable que indica que se ha seleccionado la operación de resta de las
 *        dos señales.
 * bx_y: Variable que indica que se ha seleccionado la operación x vs y de las
 *        dos señales.
 * Si la escala de tiempo por división es menor que 2 se envía solo un dato para
 * ser graficado.
 * Si la escala de tiempo por división es mayor que 2 se debe recorrer el arreglo
 * para enviar dato por dato.
 * bacopleGndX: Representa si el canal X:(1 ó 2) se encuentran en acople GND.
 *              Si el canal se encuentra en acople GND, se gráfica una linea 
 *              en el eje x de la pantalla, representando 0 voltios.  
*******************************************************************************/

void Osciloscopio::recorrerDatos(int num_canal){
     int icont;
     char cvpp1 [4];
     char cvpp2 [4];
     if (num_canal == 1){
        opantalla->TraceColour(Fl_Color(canal1->ncolor));
        free(opantalla->ScopeData2);
        if (bacopleGnd1 == 1){
           if (otiempoDiv->value()<8){                             // !!!!!!!!!Toca cambiarlo a < 2 
            //if (otiempoDiv->value()<3){                             // !!!!!!!!!Toca cambiarlo a < 2 
                 opantalla->Add((canal1->oposx->value()*255)+33000,255); 
                 ogrilla->redraw();
                 odispOsc1->redraw();
            }
            else{
                 //for(icont=0;icont < SIZE_OSC-1 ; icont++){
                 for(icont=0;icont < 571; icont++){
                     opantalla->Add((canal1->oposx->value()*255)+33000,255); 
                     ogrilla->redraw();
                     odispOsc1->redraw();            
                 }
            }              
        }
        else{                         
            if (otiempoDiv->value()<8){                             // !!!!!!!!!Toca cambiarlo a < 2 
            //if (otiempoDiv->value()<3){                             // !!!!!!!!!Toca cambiarlo a < 2 
                 icont_datos ++;
                 idatoGrafCh1 = idato_osc_ch1;
                 vpp(idato_osc_ch1,0,1); 
                 opantalla->Add((canal1->oposx->value()*255)+(idatoGrafCh1*255),255);
                 ogrilla->redraw();
                 odispOsc1->redraw();
                 if (icont_datos == 399){             
                    imayor1 = 0;           // Inicializar el valor mayor para el canal 1
                    imenor1 = 510;         // Inicializar el valor menor para el canal 1
                    icont_datos = 0;
                 }
            }
            else{
                 //for(icont=0;icont < SIZE_OSC-1 ; icont++){
                 for(icont=0;icont < 571; icont++){
                     idatoGrafCh1 = buf_osc_ch1[icont];
                     vpp(idatoGrafCh1,0,1); 
                     opantalla->Add((canal1->oposx->value()*255)+(idatoGrafCh1*255),255);
                     ogrilla->redraw(); 
                     odispOsc1->redraw();             
                 }
                 itoa(ivppCh1,cvpp1,10);
                 imayor1 = 0;           // Inicializar el valor mayor para el canal 1
                 imenor1 = 510;         // Inicializar el valor menor para el canal 1
            }                
       }
     }
     if (num_canal == 2){
        opantalla->TraceColour(Fl_Color(canal2->ncolor)); 
        if (bacopleGnd2 == 1){
            if (otiempoDiv->value()<8){                             // !!!!!!!!!Toca cambiarlo a < 2 
            //if (otiempoDiv->value()<3){                             // !!!!!!!!!Toca cambiarlo a < 2
                 opantalla->Add(255,(canal2->oposx->value()*255)+33000); 
                 ogrilla->redraw();
                 odispOsc2->redraw();
            }
            else{
                 //for(icont=0;icont < SIZE_OSC-1 ; icont++){
                 for(icont=0;icont < 571; icont++){
                     opantalla->Add(255,(canal2->oposx->value()*255)+33000); 
                     ogrilla->redraw();
                     odispOsc2->redraw();              
                 }
            }              
        }
        else {                               
             if (otiempoDiv->value()<8){                                  // !!!!!!!!!Toca cambiarlo a < 2 
             //if (otiempoDiv->value()<3){                             // !!!!!!!!!Toca cambiarlo a < 2
                  icont_datos ++;
                  idatoGrafCh2 = idato_osc_ch2;
                  vpp(0,idato_osc_ch2,2); 
                  opantalla->Add(255,(canal2->oposx->value()*255)+(idatoGrafCh2*255));  
                  ogrilla->redraw();
                  odispOsc2->redraw();
                  if (icont_datos == 399){             
                     imayor2 = 0;           // Inicializar el valor mayor para el canal 2
                     imenor2 = 510;         // Inicializar el valor menor para el canal 2
                     icont_datos = 0;
                  }
             }
             else{
                  //for(icont=0;icont < SIZE_OSC-1 ; icont++){
                  for(icont=0;icont < 571; icont++){ 
                     idatoGrafCh2 = buf_osc_ch2[icont];
                     vpp(0,idatoGrafCh2,2);
                     opantalla->Add(255,(canal2->oposx->value()*255)+(idatoGrafCh2*255)); 
                     ogrilla->redraw();
                     odispOsc2->redraw();
                  }
                  imayor2 = 0;           // Inicializar el valor mayor para el canal 1
                  imenor2 = 510;         // Inicializar el valor menor para el canal 1
             }
        }                 
     }
     if (num_canal == 3){         
             if (otiempoDiv->value()<8){                                      // !!!!!!!!!Toca cambiarlo a < 2
             //if (otiempoDiv->value()<3){                             // !!!!!!!!!Toca cambiarlo a < 2
                  opantalla->TraceColour(Fl_Color(canal2->ncolor)); 
                  idatoGrafCh2 = idato_osc_ch2;  
                  idatoGrafCh1 = idato_osc_ch1; 
                  if (bsuma == 1){
                     if (bacopleGnd1 == 1){
                           opantalla->bdual=0;            
                           opantalla->Add((canal1->oposx->value()*255)+33000,(canal2->oposx->value()*255)+(idatoGrafCh2*255));
                           ogrilla->redraw();
                           odispOsc1->redraw();
                           odispOsc2->redraw();
                        }
                        else if (bacopleGnd2 == 1){
                             opantalla->bdual=0;
                             opantalla->Add((canal1->oposx->value()*255)+(idatoGrafCh1*255),(canal2->oposx->value()*255)+33000);
                             ogrilla->redraw();
                             odispOsc1->redraw();
                             odispOsc2->redraw();
                        } 
                        else {
                             opantalla->Add((canal1->oposx->value()*255)+((idatoGrafCh2*255)+(idatoGrafCh1*255)),255);
                             ogrilla->redraw();
                        }
                  }
                  else if (bresta == 1){
                       if (bacopleGnd1 == 1){
                           opantalla->bdual=0;            
                           opantalla->Add((canal1->oposx->value()*255)+33000,(canal2->oposx->value()*255)+(idatoGrafCh2*255));
                           ogrilla->redraw();
                           odispOsc1->redraw();
                           odispOsc2->redraw();
                        }
                        else if (bacopleGnd2 == 1){
                             opantalla->bdual=0;
                             opantalla->Add((canal1->oposx->value()*255)+(idatoGrafCh1*255),(canal2->oposx->value()*255)+33000);
                             ogrilla->redraw();
                             odispOsc1->redraw();
                             odispOsc2->redraw();
                        } 
                        else {      
                             opantalla->Add((canal1->oposx->value()*255)+((idatoGrafCh2*255)-(idatoGrafCh1*255)),255);    
                             ogrilla->redraw();
                        } 
                  }
                  else if (bx_y == 1){     
                       opantalla->bdual = 1;
                       opantalla->blissajous = 1;
                       opantalla->Add((canal1->oposx->value()*255)+(idatoGrafCh1*255),(canal2->oposx->value()*255)+(idatoGrafCh2*255)); //es
                       ogrilla->redraw();
                  }
                  else if (bx_y == 0 && bsuma == 0 && bresta == 0){       
                       if (bacopleGnd2 == 1 && bacopleGnd1 == 1){
                           opantalla->bdual=0;            
                           opantalla->Add((canal1->oposx->value()*255)+33000,(canal2->oposx->value()*255)+33000);
                           ogrilla->redraw();
                           odispOsc1->redraw();
                           odispOsc2->redraw();
                        }
                        else if (bacopleGnd2 == 1){
                             opantalla->bdual=0;
                             opantalla->Add((canal1->oposx->value()*255)+(idatoGrafCh1*255),(canal2->oposx->value()*255)+33000);
                             ogrilla->redraw();
                             odispOsc1->redraw();
                             odispOsc2->redraw();
                        } 
                        else if (bacopleGnd1 == 1){
                             opantalla->bdual=0;
                             opantalla->Add((canal1->oposx->value()*255)+33000,(canal2->oposx->value()*255)+(idatoGrafCh2*255));
                             ogrilla->redraw();
                             odispOsc1->redraw();
                             odispOsc2->redraw();
                        }
                        else {
                          opantalla->Add((canal1->oposx->value()*255)+(idatoGrafCh1*255),(canal2->oposx->value()*255)+(idatoGrafCh2*255)); //es
                          ogrilla->redraw();
                          odispOsc1->redraw();
                          odispOsc2->redraw();
                        }
                  }
             }
             else{
                  //for(icont=0;icont < SIZE_OSC-1 ; icont++){
                  for(icont=0;icont < 571; icont++){
                     idatoGrafCh1 = buf_osc_ch1[icont];
                     idatoGrafCh2 = buf_osc_ch2[icont];
                     if (bsuma == 1){ 
                        if (bacopleGnd1 == 1){
                           opantalla->bdual=0;
                           opantalla->Add((canal1->oposx->value()*255)+33000,(canal2->oposx->value()*255)+(idatoGrafCh2*255));
                           ogrilla->redraw();
                           odispOsc1->redraw();
                           odispOsc2->redraw();
                        }
                        else if (bacopleGnd2 == 1){
                             opantalla->bdual=0;
                             opantalla->Add((canal1->oposx->value()*255)+(idatoGrafCh1*255),(canal2->oposx->value()*255)+33000);
                             ogrilla->redraw();
                             odispOsc1->redraw();
                             odispOsc2->redraw();
                        } 
                        else {       
                             opantalla->bdual=1;  
                             opantalla->Add((-65000)+((idatoGrafCh2*255)+(idatoGrafCh1*255)),255); //es    
                             ogrilla->redraw();
                        }              
                     }
                     else if (bresta == 1){
                          if (bacopleGnd1 == 1){
                           opantalla->bdual=0;
                           opantalla->Add((canal1->oposx->value()*255)+33000,(canal2->oposx->value()*255)+(idatoGrafCh2*255));
                           ogrilla->redraw();
                           odispOsc1->redraw();
                           odispOsc2->redraw();
                        }
                        else if (bacopleGnd2 == 1){
                             opantalla->bdual=0;
                             opantalla->Add((canal1->oposx->value()*255)+(idatoGrafCh1*255),(canal2->oposx->value()*255)+33000);
                             ogrilla->redraw();
                             odispOsc1->redraw();
                             odispOsc2->redraw();
                        } 
                        else { 
                          opantalla->Add((35000)+((idatoGrafCh2*255)-(idatoGrafCh1*255)),255); //es   
                          ogrilla->redraw();
                        }               
                     }
                     else if (bx_y == 1){              
                          opantalla->bdual = 1;
                          opantalla->blissajous = 1; 
                          opantalla->Add((idatoGrafCh1*255),(idatoGrafCh2*255));   
                          ogrilla->redraw();           
                     }
                     else if (bx_y == 0 && bsuma == 0 && bresta == 0){
                        if (bacopleGnd2 == 1 && bacopleGnd1 == 1){
                           opantalla->bdual=0;
                           opantalla->Add((canal1->oposx->value()*255)+33000,(canal2->oposx->value()*255)+33000);
                           ogrilla->redraw();
                           odispOsc1->redraw();
                           odispOsc2->redraw();
                        }
                        else if (bacopleGnd2 == 1){
                             opantalla->bdual=0;
                             opantalla->Add((canal1->oposx->value()*255)+(idatoGrafCh1*255),(canal2->oposx->value()*255)+33000);
                             ogrilla->redraw();
                             odispOsc1->redraw();
                             odispOsc2->redraw();
                        } 
                        else if (bacopleGnd1 == 1){
                             opantalla->bdual=0;
                             opantalla->Add((canal1->oposx->value()*255)+33000,(canal2->oposx->value()*255)+(idatoGrafCh2*255));
                             ogrilla->redraw();
                             odispOsc1->redraw();
                             odispOsc2->redraw();
                        }
                        else {
                          opantalla->Add((canal1->oposx->value()*255)+(idatoGrafCh1*255),(canal2->oposx->value()*255)+(idatoGrafCh2*255)); //es
                          ogrilla->redraw();
                          odispOsc1->redraw();
                          odispOsc2->redraw();
                        }
                     }
                  }              
             }                   
     }      
}


/*******************************************************************************
 * Osciloscopio::cbLogOsc: Callback del botón que activa el almacenamiento en 
 *                           archivos planos de texto de los datos capturados 
 *                           para el osciloscopio.  
 * El Callaback consta de la función static e inline cbLogOsc y cbLogOscIn.
 * osc_ch1.txt: Archivo plano de texto que contiene los datos muestreados de la
 *              señal del canal 1. 
 * osc_ch2.txt: Archivo plano de texto que contiene los datos muestreados de la
 *              señal del canal 2.
*******************************************************************************/

void Osciloscopio::cbLogOsc(Fl_Widget* pboton, void *pany){
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbLogOscIn();
}

void Osciloscopio::cbLogOscIn(){
    ofstream log("osc_ch1.txt");
    for(int icont=0;icont < 571; icont++){
         log << buf_osc_ch1[icont] << endl;             
    }
	log.close(); 
		
	ofstream log2("osc_ch2.txt");
    for(int icont=0;icont < 571; icont++){
         log2 << buf_osc_ch2[icont] << endl;             
    }
	log2.close();
}


/*******************************************************************************
 * Osciloscopio::muestreoTimer: Rutina para iniciar uno de los timers deacuerdo 
 *                               a la escala de tiempo por división seleccionada.
 * isel: Variable que indica la selección de timer.                              
 * isel = 1: Selecciona el timer para solicitar al hardware los cuatro vectores
 *           que contienen los datos muestrados de la(s) señal(es) presente(s) 
 *           en el(los) canal(es) activo(s).
 * isel = 2: Selecciona el timer para solicitar al hardware una muestra de la
 *           señal presente en el(los) canal(es) activo(s).          
*******************************************************************************/

void Osciloscopio::muestreoTimer(int isel){
     if (isel==1){
        Fl::add_timeout(0.2, cbTimerVectores, this);
     }
     else{
        Fl::add_timeout(0.3, cbTimer, this);
     }
}


/*******************************************************************************
 * Osciloscopio::cbAcople1: Callback del botón selector del modo de acople
 *                           del canal 1 del osciloscopio. 
 * El Callaback consta de la función static e inline cbAcople1 y cbAcople1In.
 * isec_acople : Variable que representa la selección del tipo de acople para
 *               el canal 1.
 * isec_acople = 0 : Acople AC.  
 * isec_acople = 1 : Acople DC.
 * isec_acople = 2 : Acople GND.
*******************************************************************************/

void Osciloscopio::cbAcople1(Fl_Widget* pboton, void *pany){
     Osciloscopio* posc=(Osciloscopio*)pany;       
     posc->cbAcople1In();
}

void Osciloscopio::cbAcople1In(){
  if (isec_acople==0){
     canal1->oacopGnd->color(FL_GRAY);
     canal1->oacopGnd->redraw();
     bacopleGnd1 = 0;
     Encapsular('A', 'e', '1', '2',0x00,0x00);
     Transmision();
     if (bhardware){
        canal1->oacopAc->color(FL_RED);
        canal1->oacopAc->redraw();
        strcpy(odispOsc1->cacople,"AC");
        odispOsc1->redraw();
     }
     else{
         fl_message("Error de hardware"); 
     }
  }
  if (isec_acople==1){
     canal1->oacopAc->color(FL_GRAY);
     canal1->oacopAc->redraw();
     Encapsular('A', 'e', '1', '1',0x00,0x00);
     Transmision();
     if (bhardware){
        canal1->oacopDc->color(FL_RED);
        canal1->oacopDc->redraw();
        strcpy(odispOsc1->cacople,"DC");
        odispOsc1->redraw();
     }
     else{
         fl_message("Error de hardware"); 
     }
  }
  if (isec_acople==2){
     canal1->oacopDc->color(FL_GRAY);
     canal1->oacopDc->redraw();
     Encapsular('A', 'e', '1', '3',0x00,0x00);
     Transmision();
      if (bhardware){
         canal1->oacopGnd->color(FL_RED);
         canal1->oacopGnd->redraw();
         bacopleGnd1 = 1;
         strcpy(odispOsc1->cacople,"GND");
         odispOsc1->redraw();
      }
     else{
         fl_message("Error de hardware"); 
     }
     isec_acople=-1;
  }
     isec_acople++;  
}


/*******************************************************************************
 * Osciloscopio::cbAcople2: Callback del botón selector del modo de acople
 *                           del canal 2 del osciloscopio. 
 * El Callaback consta de la función static e inline cbAcople2 y cbAcople2In.
 * isec_acople : Variable que representa la selección del tipo de acople para
 *               el canal 2.
 * isec_acople2 = 0 : Acople AC.  
 * isec_acople2 = 1 : Acople DC.
 * isec_acople2 = 2 : Acople GND.
*******************************************************************************/

void Osciloscopio::cbAcople2(Fl_Widget* pboton, void *pany){
     Osciloscopio* posc=(Osciloscopio*)pany;       
     posc->cbAcople2In();
}

void Osciloscopio::cbAcople2In(){
  if (isec_acople2==0){
     canal2->oacopGnd->color(FL_GRAY);
     canal2->oacopGnd->redraw();
     bacopleGnd2 = 0;
     Encapsular('B', 'e', '1', '2',0x00,0x00);
     Transmision();
     if (bhardware){
        canal2->oacopAc->color(FL_RED);
        canal2->oacopAc->redraw();
        strcpy(odispOsc2->cacople,"AC");
        odispOsc2->redraw();
     }
     else{
         fl_message("Error de hardware"); 
     }
  }
  if (isec_acople2==1){
     canal2->oacopAc->color(FL_GRAY);
     canal2->oacopAc->redraw();
     Encapsular('B', 'e', '1', '1',0x00,0x00);
     Transmision();
     if (bhardware){
        canal2->oacopDc->color(FL_RED);
        canal2->oacopDc->redraw();
        strcpy(odispOsc2->cacople,"DC");
        odispOsc2->redraw();
     }
     else{
         fl_message("Error de hardware"); 
     }
  }
  if (isec_acople2==2){
     canal2->oacopDc->color(FL_GRAY);
     canal2->oacopDc->redraw();
     Encapsular('B', 'e', '1', '3',0x00,0x00);
     Transmision();
      if (bhardware){
         canal2->oacopGnd->color(FL_RED);
         canal2->oacopGnd->redraw();
         bacopleGnd2 = 1;
         strcpy(odispOsc2->cacople,"GND");
         odispOsc2->redraw();
      }
     else{
         fl_message("Error de hardware"); 
     }
     isec_acople2=-1;
  }
     isec_acople2++;  
}


/*******************************************************************************
 * Osciloscopio::cbAyuda: Callback del botón que activa los globos de ayuda
 *                         flotante para cada botón del osciloscopio.
 * El Callaback consta de la función static e inline cbAyuda y cbAyudaIn.
*******************************************************************************/
void Osciloscopio::cbAyuda(Fl_Widget* pboton, void *pany){
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbAyudaIn();
}

void Osciloscopio::cbAyudaIn(){
     if (oayudaOsc->value() == 1){
        Fl_Tooltip::enable();
     }
    // else{
    //     Fl_Tooltip::disable(); 
    // }
}


/*******************************************************************************
 * Osciloscopio::cbHelp: Callback del botón que lanza la ayuda del uso del
 *                        instrumento. 
 * El Callaback consta de la función static e inline cbHelp y cbHelpIn.
 * Se despliega una ventana de ayuda con un archivo en html con la guia de
 * usuario del instrumento.
*******************************************************************************/
/*void Osciloscopio::cbHelp(Fl_Widget* pboton, void *any){
     Osciloscopio* posc=(Osciloscopio*)any;
     posc->cbHelpIn();
}

/*void Osciloscopio::cbHelpIn(){
     // manual->show();
}*/



/*******************************************************************************
 * Osciloscopio::cbAuto: Callback del botón que ajusta automáticamente el
 *                        instrumento. 
 * El Callaback consta de la función static e inline cbAuto y cbAutoIn.
 * Se debe configurar primero el acople del canal 1 en AC. 
 * La escala de Tiempo por división se configura en 50 mS/Div. en caso de que la
 * señal presente en el canal sea lenta.
 * De acuerdo al valor pico a pico que envía el hardware se cambia la escala de
 * voltios por división para que la señal se vea en las 4 divisiones centrales 
 * de la pantalla.  
*******************************************************************************/
void Osciloscopio::cbAuto(Fl_Widget* pboton, void *any){
     Osciloscopio* posc=(Osciloscopio*)any;
     posc->cbAutoIn();
}

void Osciloscopio::cbAutoIn(){
     
     canal1->oacopDc->color(FL_GRAY);
     canal1->oacopDc->redraw();
     canal1->oacopGnd->color(FL_GRAY);
     canal1->oacopGnd->redraw();
     Encapsular('A', 'e', '1', '2',0x00,0x00);                     // Configurar acople ac 
     Transmision();
     if (bhardware){
        canal1->oacopAc->color(FL_RED);
        canal1->oacopAc->redraw();
     }
     else{
         fl_message("Error de hardware"); 
     }
     otiempoDiv->value(10);
     Encapsular('L','d','1','A',0x00,0x00);                        //Configurar T/Div  mas lenta por vectores
     //Encapsular('L','d','8','0',0x00,0x00);                      //Configurar T/Div  mas lenta por vectores
     Fl::remove_timeout(cbTimer,this);
     Fl::remove_timeout(cbTimerVectores,this);  
     Transmision();
     if (bhardware){
         muestreoTimer(1);                                        //Solicitar envío de muestras en vectores 
     }
     else
         fl_message("Error de hardware");
     
          if (ivppCh1 < 64 || ivppCh1 > 128){
              if (ivppCh1 >= 128){
                 if(canal1->ovoltDiv->value() > 1){
                    canal1->omenuvDiv->value(canal1->omenuvDiv->value()-1);
                    canal1->ovoltDiv->value(canal1->ovoltDiv->value()-1);
                    cbVoltDiv1In( canal1->ovoltDiv);
                 }
              }
              else if (ivppCh1 <= 64){
                 if(canal1->ovoltDiv->value() < 11){
                    canal1->omenuvDiv->value(canal1->omenuvDiv->value()+1);
                    canal1->ovoltDiv->value(canal1->ovoltDiv->value()+1);
                    cbVoltDiv1In( canal1->ovoltDiv);
                 } 
              }
          }
}


/*******************************************************************************
 * Osciloscopio::vpp(): Rutina que calcula el valor pico a pico de las señales
 *                      graficadas. 
 * ivalor1: Variable que contiene el dato del canal 1.
 * ivalor2: Variable que contiene el dato del canal 2.
 * icanal:  Número del canal que envía los datos.
 * icanal = 1: Datos enviados por el canal 1.
 * icanal = 2: Datos enviados por el canal 2.
 * icanal = 3: Datos enviados por los 2 canales.   
*******************************************************************************/

void Osciloscopio::vpp(int ivalor1, int ivalor2, int icanal){
     
     if (icanal == 1) {
        if (ivalor1 < imenor1){
           imenor1 = ivalor1;             
        }
         if (ivalor1 > imayor1){
             imayor1 = ivalor1;           
        }
        ivppCh1 = imayor1 - imenor1; 
     }      
     else if(icanal==2){
          if (ivalor2 > imayor2){
             imayor2 = ivalor2;               
          }
          if (ivalor2 < imenor2){
               imenor2 = ivalor2;
          }
          ivppCh2 = imayor2 - imenor2;  
     } 
     else if(icanal==3){
          if (ivalor1 > imayor1){
             imayor1 = ivalor1;               
           }
           else if (ivalor1 < imenor1){
                imenor1 = ivalor1;
           }
           ivppCh1 = imayor1 - imenor1;
           
           if (ivalor2 > imayor2){
              imayor2 = ivalor2;               
           }
           else if (ivalor2 < imenor2){
                imenor2 = ivalor2;
           }
           ivppCh2 = imayor2 - imenor2; 
     }     
           
}



/*******************************************************************************
 * Osciloscopio::cbTdivXXs: Callbacks del menú de tiempo por división para 
 *                           modificar la posición de la perilla selectora de la
 *                           escala de tiempo por división.
 * Están los 18 callbacks pertenecientes a cada una de las escalas que tiene el
 * menú. 
*******************************************************************************/

void Osciloscopio::cbTdiv05s(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbTdiv05sIn(pselector);
}

void Osciloscopio::cbTdiv05sIn(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempoDiv->value(pselector->value());
}

void Osciloscopio::cbTdiv02s(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbTdiv02sIn(pselector);
}

void Osciloscopio::cbTdiv02sIn(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempoDiv->value(pselector->value());
}


void Osciloscopio::cbTdiv01s(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbTdiv01sIn(pselector);
}

void Osciloscopio::cbTdiv01sIn(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempoDiv->value(pselector->value());
}


void Osciloscopio::cbTdiv50ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbTdiv50msIn(pselector);
}

void Osciloscopio::cbTdiv50msIn(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempoDiv->value(pselector->value());
}


void Osciloscopio::cbTdiv20ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbTdiv20msIn(pselector);
}

void Osciloscopio::cbTdiv20msIn(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempoDiv->value(pselector->value());
}


void Osciloscopio::cbTdiv10ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbTdiv10msIn(pselector);
}

void Osciloscopio::cbTdiv10msIn(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempoDiv->value(pselector->value());
}

void Osciloscopio::cbTdiv5ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbTdiv5msIn(pselector);
}

void Osciloscopio::cbTdiv5msIn(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempoDiv->value(pselector->value());
}


void Osciloscopio::cbTdiv2ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbTdiv2msIn(pselector);
}

void Osciloscopio::cbTdiv2msIn(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempoDiv->value(pselector->value());
}


void Osciloscopio::cbTdiv1ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbTdiv1msIn(pselector); 
}

void Osciloscopio::cbTdiv1msIn(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempoDiv->value(pselector->value());
}



void Osciloscopio::cbTdiv05ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbTdiv05msIn(pselector);
}

void Osciloscopio::cbTdiv05msIn(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempoDiv->value(pselector->value());
}

void Osciloscopio::cbTdiv02ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbTdiv02msIn(pselector);
}

void Osciloscopio::cbTdiv02msIn(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempoDiv->value(pselector->value());
}



void Osciloscopio::cbTdiv01ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbTdiv01msIn(pselector);
}

void Osciloscopio::cbTdiv01msIn(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempoDiv->value(pselector->value());
}


void Osciloscopio::cbTdiv50us(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbTdiv50usIn(pselector);
}

void Osciloscopio::cbTdiv50usIn(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempoDiv->value(pselector->value());
}


void Osciloscopio::cbTdiv20us(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbTdiv20usIn(pselector); 
}

void Osciloscopio::cbTdiv20usIn(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempoDiv->value(pselector->value());
}

void Osciloscopio::cbTdiv10us(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbTdiv10usIn(pselector);
}

void Osciloscopio::cbTdiv10usIn(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempoDiv->value(pselector->value());
}

void Osciloscopio::cbTdiv5us(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbTdiv5usIn(pselector);
}

void Osciloscopio::cbTdiv5usIn(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempoDiv->value(pselector->value());
}


void Osciloscopio::cbTdiv2us(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbTdiv2usIn(pselector); 
}

void Osciloscopio::cbTdiv2usIn(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempoDiv->value(pselector->value());
}

void Osciloscopio::cbTdiv1us(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cbTdiv1usIn(pselector);
}

void Osciloscopio::cbTdiv1usIn(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempoDiv->value(pselector->value());
}


// Destructor de clase
Osciloscopio::~Osciloscopio(){
	// insert your code here
}

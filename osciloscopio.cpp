// Class automatically generated by Dev-C++ New Class wizard

#include "osciloscopio.h" // class's header file
#include <FL/Fl.H>

int isec_ch;              // Variable global para realizar la secuencia de la selección de canales 
int isec_dual;            // Variable global para realizar la secuencia del menu dual 
int isec_trigger;         // Variable global para realizar la secuencia del menu dual
int isec_acople;          // Variable global para realizar la secuencia del acople


// Constructor de clase
Osciloscopio::Osciloscopio(int x, int y, int w, int h, const char *l, int ncol):Instrumento()
{
    icolor = ncol;                                                //Color de fondo de la pantalla del osciloscopio
    strcpy(cnombre,"osc.txt");                                    //Nombre para el archivo de texto donde se almacenan los datos
                
    ogroup_osc = new Fl_Group (5,5,680,360,"");                   // Agrupa los elementos del osciloscopio
    ogroup_osc->box(FL_ENGRAVED_FRAME);                 
    ogroup_osc->box(FL_UP_BOX);
    ogroup_osc->deactivate();                           
    canal1 = new Canal(400,9,130,230,"",255);                     // Instancia de canal para crear el objeto canal 1
    canal2 = new Canal(545,9,130,230,"",250);                     // Instancia de canal para crear el objeto canal 2
    osel_ch = new Fl_Repeat_Button(110,335,40,18,"Canal");        // Boton para seleccionar el canal o canales activos
    osel_ch->labelsize(10);
    och1 = new Fl_Light_Button(160,340,10,10,"CH1");              // Indicador luminoso para el canal 1
    och1->labelsize(10);
    och1->box(FL_NO_BOX);
    och1->align(FL_ALIGN_TOP);
    och2 = new Fl_Light_Button(185,340,10,10,"CH2");              // Indicador luminoso para el canal 2
    och2->labelsize(10);
    och2->box(FL_NO_BOX);
    och2->align(FL_ALIGN_TOP);
    odual_menu = new Fl_Repeat_Button(230,335,40,18,"Dual");      // Boton para seleccionar la operacion dual suma resta o lissajous 
    odual_menu->labelsize(10);
    odual_menu->deactivate();
    osuma = new Fl_Light_Button(290,340,10,10,"Suma");            // Indicador luminoso para la operacion de suma de las dos señales
    osuma->labelsize(10);
    osuma->box(FL_NO_BOX);
    osuma->align(FL_ALIGN_TOP);
    oresta = new Fl_Light_Button(325,340,10,10,"Resta");          // Indicador luminoso para la operacion de resta de las dos señales
    oresta->labelsize(10);
    oresta->box(FL_NO_BOX);
    oresta->align(FL_ALIGN_TOP);
    ox_y = new Fl_Light_Button(355,340,10,10,"X_Y");              // Indicador luminoso para la operacion lissajous 
    ox_y->labelsize(10);
    ox_y->box(FL_NO_BOX);
    ox_y->align(FL_ALIGN_TOP);
    olog_osc  = new Fl_Button (15,320,40,18,"Log");               // Boton para activar el almacenamiento en archivo de texto los datos
    olog_osc->labelsize(10);
    ohelp_osc  = new Fl_Button (15,342,40,18,"Help");
    ohelp_osc->labelsize(10);
    ogroup_osc->end();  
    
    ogroup_tdiv = new Fl_Group (400,243,240,115,"");              //Agrupa los controles de tiempo por división
    ogroup_tdiv->box(FL_ENGRAVED_FRAME);
    ogroup_tdiv->box(FL_UP_BOX);
    ogroup_tdiv->deactivate();
    otiempo_div = new Fl_Knob (405,250,70,70,"T_DIV");
    otiempo_div->color(147);
    otiempo_div->type(8);
    otiempo_div->labelsize(9);
    otiempo_div->scaleticks(17);
    otiempo_div->range(0,17);
    omenu_t_div = new Fl_Choice(415,335,50,20,"");
    omenu_t_div->add("0.5 s",FL_ALT,(Fl_Callback *)cb_tdiv05s,this);
    omenu_t_div->add("0.2 s",FL_ALT,(Fl_Callback *)cb_tdiv02s,this);
    omenu_t_div->add("0.1 s",FL_ALT,(Fl_Callback *)cb_tdiv01s,this);
    omenu_t_div->add("50 m",FL_ALT,(Fl_Callback *)cb_tdiv50ms,this);
    omenu_t_div->add("20 m",FL_ALT,(Fl_Callback *)cb_tdiv20ms,this);
    omenu_t_div->add("10 m",FL_ALT,(Fl_Callback *)cb_tdiv10ms,this);
    omenu_t_div->add("5 m",FL_ALT,(Fl_Callback *)cb_tdiv5ms,this);
    omenu_t_div->add("2 m",FL_ALT,(Fl_Callback *)cb_tdiv2ms,this);
    omenu_t_div->add("1 m",FL_ALT,(Fl_Callback *)cb_tdiv1ms,this);
    omenu_t_div->add("0.5 m",FL_ALT,(Fl_Callback *)cb_tdiv05ms,this);
    omenu_t_div->add("0.2 m",FL_ALT,(Fl_Callback *)cb_tdiv02ms,this);
    omenu_t_div->add("0.1 m",FL_ALT,(Fl_Callback *)cb_tdiv01ms,this);
    omenu_t_div->add("50 u",FL_ALT,(Fl_Callback *)cb_tdiv50us,this);
    omenu_t_div->add("20 u",FL_ALT,(Fl_Callback *)cb_tdiv20us,this);
    omenu_t_div->add("10 u",FL_ALT,(Fl_Callback *)cb_tdiv10us,this);
    omenu_t_div->add("5 u",FL_ALT,(Fl_Callback *)cb_tdiv5us,this);
    omenu_t_div->add("2 u",FL_ALT,(Fl_Callback *)cb_tdiv2us,this);
    omenu_t_div->add("1 u",FL_ALT,(Fl_Callback *)cb_tdiv1us,this);            
    opos_y = new Fl_Knob (495,255,50,50,"X-Pos");
    opos_y->color(180);
    opos_y->scaleticks(0);
    opos_y->cursor(40);
    opos_y->range(0,10);
    ov_posx = new Fl_Value_Output(500,335,50,20,"");
    osel_trigger = new Fl_Repeat_Button(580,310,40,18,"Trigger");  
    osel_trigger->labelsize(10);
    otrigger_ch1 = new Fl_Light_Button(580,275,10,10,"Ch1");
    otrigger_ch1->labelsize(10);
    otrigger_ch1->box(FL_NO_BOX);
    otrigger_ch1->align(FL_ALIGN_RIGHT);
    otrigger_ch2 = new Fl_Light_Button(580,295,10,10,"Ch2");
    otrigger_ch2->labelsize(10);
    otrigger_ch2->box(FL_NO_BOX);
    otrigger_ch2->align(FL_ALIGN_RIGHT);
    ogroup_tdiv->end();
                
    opantalla = new Fl_Scope(8,8,380, 304,"");         //Instancia de scope
    opantalla ->TraceColour(FL_WHITE);                 //Color de la grafica
    opantalla->tracetype(FL_SCOPE_TRACE_LOOP);  
    opantalla->redrawmode(FL_SCOPE_REDRAW_ALWAYS);
    opantalla->linetype(FL_SCOPE_LINE);
    opantalla->box(FL_DOWN_BOX);
    
    oosc_on = new Fl_Light_Button(650,340,30,20,"ON");
    oosc_on->labelsize(9);            
                
    osel_ch->callback(cb_sel_ch, this);
    odual_menu->callback(cb_dual_menu, this);    
    osel_trigger->callback(cb_sel_trigger, this);
    otiempo_div->callback(cb_tiempo_div, this);
    opos_y->callback(cb_pos_y, this);
    oosc_on->callback(cb_osc_on, this);
    olog_osc->callback(cb_log_osc, this);
    canal1->ovolt_div->callback(cb_volt_div1, this);
    canal1->osel_acople->callback(cb_acople, this);
    canal2->ovolt_div->callback(cb_volt_div2, this);
}


// Destructor de clase
Osciloscopio::~Osciloscopio(){
	// insert your code here
}

// sets the value of bsuma
void Osciloscopio::Setbsuma(bool bx){
	bsuma = bx;
}

// sets the value of bx_y
void Osciloscopio::Setbx_y(bool bx){
	bx_y = bx;
}

// sets the value of ipos_x
void Osciloscopio::Setipos_x(int ix){
	ipos_x = ix;
}

// sets the value of it_div
void Osciloscopio::Setit_div(int ix){
	it_div = ix;
}

// sets the value of ifrec_muestreo
void Osciloscopio::Setifrec_muestreo(int ix){
	ifrec_muestreo = ix;
}

// sets the value of nnivel_trigger
void Osciloscopio::Setinivel_trigger(int ix){
	inivel_trigger = ix;
}

// sets the value of bdual
void Osciloscopio::Setbdual(bool bx){
	bdual = bx;
}

/*
 * Método para sumar las señales adquiridas por los 2 canales
 * del instrumento.
 */
void Osciloscopio::sumar(int idato1[], int idato2[]){
     int icont1;
     for (icont1=0; icont1 < inum_datos; icont1++){
         idatos[icont1] = idato1[icont1]+idato2[icont1];                      // Suma de las dos señales para el eje y
     }
}

/*
 * Método para restar las señales adquiridas por los 2 canales
 * del instrumento 
 */
void Osciloscopio::restar(int idato1[], int idato2[]){
     int icont;
     for (icont=0; icont < DATA_OSC-1; icont++){
         idatos[icont] = idato1[icont] - idato2[icont];                         //Diferencia de las dos señales para el eje y
     }
}

/*
 * Método para realizar gráficas de lissajous con las señales 
 * de los 2 canales.
 */
void Osciloscopio::lissajous(int idato1[], int idato2[]){
     int icont1;
     for (icont1=0; icont1 < inum_datos; icont1++){
         idatos[icont1] = idato1[icont1];                     //Datos del canal 1 para el eje y
     }
}

/**
 * Este método es el callback del boton que enciende el osciloscopio 
 * debe ir acompañada de una función inline para poder realizar los callbacks. 
*/
void Osciloscopio::cb_osc_on(Fl_Widget* pboton, void *pany){
     Osciloscopio* posc=(Osciloscopio*)pany;       //
     posc->cb_osc_on_in();
}

/**
 * Esta función acompaña la función  cb_osc_on para realizar los llamados al 
 * callback del boton que enciende el osciloscopio con los parametros por defecto
 * Canal 1 activado, 500 uS pos division, Acople AC y 5 Voltios pos division 
*/
void Osciloscopio::cb_osc_on_in(){
      char t_div;
      if (oosc_on->value()== 1){                                
         activar(1);
         Encapsular('A','a','1','0',0x00,0x00);
         Transmision();
         if (bhardware){
            activar(1);
            ogroup_osc->activate(); 
            ogroup_tdiv->activate();     
            och1->value(1);
            canal1->activar(1);
            canal1->ogroup_ch->activate();
            otiempo_div->value(6);
            omenu_t_div->value(6);
            canal1->ovolt_div->value(0);
            canal1->oacop_ac->value(1);
            isec_acople=1;
            muestreo_timer(1);
         }
         else {
              fl_message("Error de hardware");
         }
      }
      if (oosc_on->value()== 0){
         Fl::remove_timeout(cb_timer, this);
         Fl::remove_timeout(cb_timer_vectores, this);
         activar(0);
         ogroup_osc->deactivate(); 
         ogroup_tdiv->deactivate();
      }
      isec_ch++;
}

/*
 * Este método es el callback del boton selector de canales
 * en el osciloscopio
*/
void Osciloscopio::cb_sel_ch(Fl_Widget* pboton, void *pany){
     Osciloscopio* posc=(Osciloscopio*)pany;       
     posc->cb_sel_ch_in();
}

/**
 * Esta función acompaña la función  cb_sel_ch 
 * para realizar los llamados de callback del selector de canales
 * en el osciloscopio 
*/
void Osciloscopio::cb_sel_ch_in(){
     if (isec_ch==0){
        Fl::remove_timeout(cb_timer,this);
        Fl::remove_timeout(cb_timer_vectores,this);
        opantalla->bch2 = 0;
        Encapsular('B','b','1','0',0x00,0x00);         //Desactivar canal 2
        Transmision();
        if (bhardware){
           och2->value(0);
           canal2->ogroup_ch->deactivate();
           odual_menu->deactivate();
        }
        else {
             fl_message("Error de hardware");
        }
        Encapsular('A','a','1','0',0x00,0x00);           //Activar canal 1
        Transmision();
        if (bhardware){
           och1->value(1);
           canal1->activar(1);
           opantalla->bch1 = 1;
           canal1->ogroup_ch->activate();
           if (otiempo_div->value() >= 6){
              muestreo_timer(1);
           }
           else {
                muestreo_timer(2);
           }
        }
        else {
             fl_message("Error de hardware");
        }
     }
     if (isec_ch==1){
        fl_message("entro canal 2");
        Encapsular('A','b','1','0',0x00,0x00);         //Desactivar canal 1
        Fl::remove_timeout(cb_timer,this);
        Fl::remove_timeout(cb_timer_vectores,this);
        opantalla->bch1 = 0;
        Transmision();
        if (bhardware){
           och1->value(0);
           canal1->activar(0);
           canal1->ogroup_ch->deactivate();
        }
        else {
             fl_message("Error de hardware");
        }
        Encapsular('B','a','1','0',0x00,0x00);         //Activar canal 2
        Transmision();
        if (bhardware){
           och2->value(1);
           canal2->activar(1);
           canal2->ogroup_ch->activate();
           canal2->oacop_ac->value(1);
           opantalla->bch2 = 1;
           if (otiempo_div->value() >= 6){
              muestreo_timer(1);
           }
           else {
                muestreo_timer(2);
           }
        }
        else {
             fl_message("Error de hardware");
        }
     }
     if (isec_ch==2){
        Encapsular('A','a','1','0',0x00,0x00);           //Activar canal 1
        Fl::remove_timeout(cb_timer,this);
        Fl::remove_timeout(cb_timer_vectores,this); 
        Transmision();
        if (bhardware){
           och1->value(1);
           canal1->activar(1);
           canal1->ogroup_ch->activate();
           odual_menu->activate();
           if (otiempo_div->value() >= 6){
              muestreo_timer(1);
           }
           else {
                muestreo_timer(2);
           }
        }
        else {
             fl_message("Error de hardware");
        }       
        isec_ch=-1;
     }
     isec_ch++;
}

/**
 * Este método es el callback del boton del menu de las funciones
 * duales de graficas en el osciloscopio, debe ir acompañada de una 
 * función inline para poder realizar los callbacks. 
*/
void Osciloscopio::cb_dual_menu(Fl_Widget* pboton, void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_dual_menu_in();
}

/**
 * Esta función acompaña la función  cb_menu_dual 
 * para realizar los llamados de callback del menu de funciones duales
 * de graficas en el osciloscopio 
*/
void Osciloscopio::cb_dual_menu_in(){
     if (isec_dual==0){
        opantalla->bdual = 0;
        ox_y->value(0);
        Setbsuma(1);
        osuma->value(1);
     }
     if (isec_dual==1){
        osuma->value(0);
        oresta->value(1);
     }
     if (isec_dual==2){
        oresta->value(0);
        ox_y->value(1);
        opantalla->bdual = 1;
        isec_dual=-1;
     }
     isec_dual++;
}

/**
 * Este método es el callback del boton selector de la fuente del 
 * disparo (trigger) en el osciloscopio, debe ir acompañada de una 
 * función inline para poder realizar los callbacks.  
*/
void Osciloscopio::cb_sel_trigger(Fl_Widget* pboton, void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_sel_trigger_in();
}

/**
 * Esta función acompaña la función  cb_sel_trigger para realizar 
 * los llamados de callback del boton selector de la fuente del
 * trigger en el osciloscopio 
*/
void Osciloscopio::cb_sel_trigger_in(){
     if (isec_trigger==0){
        otrigger_ch2->value(0);
        otrigger_ch1->value(1);
     }
     if (isec_trigger==1){
        otrigger_ch1->value(0);
        otrigger_ch2->value(1);
        isec_trigger=-1;
     }
     isec_trigger++;
}

/**
 * Este método es el callback del boton selector de la escala de 
 * tiempo por división en el osciloscopio, debe ir acompañada de una 
 * función inline para poder realizar los callbacks.  
*/
void Osciloscopio::cb_tiempo_div(Fl_Widget* psel, void *pany)
{
     Fl_Knob *pselector = (Fl_Knob *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tiempo_div_in(pselector);
}

/**
 * Esta función acompaña la función  cb_tiempo_div 
 * para realizar los llamados de callback del boton selector de la
 * escala de tiempo por división en el osciloscopio 
*/
void Osciloscopio::cb_tiempo_div_in(Fl_Widget* psel){
     char t_div;
     Fl_Knob *pselector = (Fl_Knob *)psel;
     pselector->value(floor(pselector->value()));
     omenu_t_div->value(pselector->value());
     if (pselector->value()>=6){
        t_div = pselector->value()+48;                      //Convertir a caracter la escala de tiempo por division
        Encapsular('L','d','1',t_div,0x00,0x00);            //Configurar Tiempo por division 
        Fl::remove_timeout(cb_timer,this);
        Fl::remove_timeout(cb_timer_vectores,this);
        Transmision();
        muestreo_timer(1);
        if (~bhardware)
           fl_message("Error de hardware");
     }
     else {
          Encapsular('L','d','1','B',0x00,0x00);
          Fl::remove_timeout(cb_timer,this);
          Fl::remove_timeout(cb_timer_vectores,this);        
          Transmision();
          if (bhardware)
             muestreo_timer(2);   
     }
}

/**
 * Este método es el callback del selector de la escala de volt/div
 * del canal 1 del osciloscopio debe ir acompañada de una función 
 * inline para poder realizar los callbacks. 
*/
void Osciloscopio::cb_volt_div1(Fl_Widget* psel, void *pany)
{
     Fl_Knob *pselector = (Fl_Knob *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;          
     posc->cb_volt_div1_in(pselector);
}

/**
 * Esta función acompaña la función  cb_volt_div1  
 * para realizar los llamados de callback del selector de la escala
 * de volt/div del canal en el osciloscopio 
*/
void Osciloscopio::cb_volt_div1_in(Fl_Widget* psel){
     Fl_Knob *pselector = (Fl_Knob *)psel;
     pselector->value(floor(pselector->value()));
     canal1->omenu_v_div->value(pselector->value());                
     if (int((pselector->value()))== 10){
         Encapsular('A','c','1','A',0x00,0x00);
         Transmision();
     }
     else if (int((pselector->value()))== 11){
        Encapsular('A','c','1','B',0x00,0x00);
         Transmision();
     }
     else if (int((pselector->value()))== 12){
         Encapsular('A','c','1','C',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 1){
         Encapsular('A','c','1','1',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 2){
         Encapsular('A','c','1','2',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 3){
         Encapsular('A','c','1','3',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 4){
         Encapsular('A','c','1','4',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 5){
         Encapsular('A','c','1','5',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 6){
         Encapsular('A','c','1','6',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 7){
         Encapsular('A','c','1','7',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 8){
         Encapsular('A','c','1','8',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 9){
         Encapsular('A','c','1','9',0x00,0x00);
         Transmision();                            
     }
}


/**
 * Este método es el callback del selector de la escala de volt/div
 * del canal 2 del osciloscopio debe ir acompañada de una función 
 * inline para poder realizar los callbacks. 
*/
void Osciloscopio::cb_volt_div2(Fl_Widget* psel, void *pany)
{
     Fl_Knob *pselector = (Fl_Knob *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;          
     posc->cb_volt_div2_in(pselector);
}

/**
 * Esta función acompaña la función  cb_volt_div2  
 * para realizar los llamados de callback del selector de la escala
 * de volt/div del canal en el osciloscopio 
*/
void Osciloscopio::cb_volt_div2_in(Fl_Widget* psel){
     Fl_Knob *pselector = (Fl_Knob *)psel;
     pselector->value(floor(pselector->value()));
     canal2->omenu_v_div->value(pselector->value());                
     if (int((pselector->value()))== 10){
         Encapsular('B','c','1','A',0x00,0x00);
         Transmision();
     }
     else if (int((pselector->value()))== 11){
        Encapsular('B','c','1','B',0x00,0x00);
         Transmision();
     }
     else if (int((pselector->value()))== 12){
         Encapsular('B','c','1','C',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 1){
         Encapsular('B','c','1','1',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 2){
         Encapsular('B','c','1','2',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 3){
         Encapsular('B','c','1','3',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 4){
         Encapsular('B','c','1','4',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 5){
         Encapsular('B','c','1','5',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 6){
         Encapsular('B','c','1','6',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 7){
         Encapsular('B','c','1','7',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 8){
         Encapsular('B','c','1','8',0x00,0x00);
         Transmision();                            
     }
     else if (int((pselector->value()))== 9){
         Encapsular('B','c','1','9',0x00,0x00);
         Transmision();                            
     }
}


/**
 * Este método es el callback del boton selector de la posición 
 * de la señal respecto al eje y en el osciloscopio, debe ir acompañada 
 * de una función inline para poder realizar los callbacks.  
*/
void Osciloscopio::cb_pos_y(Fl_Widget* psel, void *pany)
{
     Fl_Knob *pselector = (Fl_Knob *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_pos_y_in(pselector);
}

/**
 * Esta función acompaña la función  cb_pos_y 
 * para realizar los llamados de callback del boton selector de la
 * posición de la señal respecto al eje y en el osciloscopio 
*/
void Osciloscopio::cb_pos_y_in(Fl_Widget* psel){
     Fl_Knob *pselector = (Fl_Knob *)psel;
     pselector->value(floor(pselector->value()));
     ov_posx->value(pselector->value());
}

/**
 * Este método es el callback del timer para realizar la solicitud 
 * de datos uno a uno en el osciloscopio.  
*/
void Osciloscopio::cb_timer(void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_timer_in();
}

/**
 * Esta función acompaña la función cb_timer para realizar los llamados 
 * de callback del timer de solicitud de muestras una a una 
*/
void Osciloscopio::cb_timer_in(){
     Encapsular('L','y','1','0',0x00,0x00);
     Transmision();
     recorrer_datos(isec_ch);
     switch (omenu_t_div->value()){
            case 0:
                 Fl::repeat_timeout(0.002, cb_timer, this);
                 break;
            case 1:
                 Fl::repeat_timeout(0.005, cb_timer, this);
                 break; 
            case 2:
                 Fl::repeat_timeout(0.01, cb_timer, this); 
                 break;
            case 3:
                 Fl::repeat_timeout(0.02, cb_timer, this); 
                 break;
            case 4:
                 Fl::repeat_timeout(0.05, cb_timer, this); 
                 break;
            case 5:
                 Fl::repeat_timeout(0.1, cb_timer, this);
                 break; 
            case 6:      
                 Fl::repeat_timeout(0.2, cb_timer, this); 
                 break;
            case 7:
                 Fl::repeat_timeout(0.5, cb_timer, this); 
                 break;
     }
   
}


/**
 * Este método es el callback del timer para realizar la solicitud 
 * de vectores de datos del osciloscopio.  
*/
void Osciloscopio::cb_timer_vectores(void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_timer_vectores_in();
}


/**
 * Esta función acompaña la función cb_timer para realizar los llamados 
 * de callback del timer de solicitud de muestras una a una 
*/
void Osciloscopio::cb_timer_vectores_in(){
     if (canal1->bestado && ~canal2->bestado){
        Encapsular('L', 'p', '1', '0',0x00,0x00);                //Trama Osc14   
        Transmision();
        if (ch1_muestreado){
           Encapsular('A', 'p', '1', '1',0x00,0x00);             //Trama Osc16 
           Transmision();
           Encapsular('A', 'p', '1', '2',0x00,0x00);             //Trama Osc16
           Transmision();
           Encapsular('A', 'p', '1', '3',0x00,0x00);             //Trama Osc16
           Transmision();
           Encapsular('A', 'p', '1', '4',0x00,0x00);             //Trama Osc16
           Transmision();
           recorrer_datos(1);
        }
     }
     if (canal2->bestado && ~canal1->bestado){
        Encapsular('L', 'p', '1', '0',0x00,0x00);
        Transmision();
        if (ch2_muestreado){
           Encapsular('B', 'p', '1', '1',0x00,0x00);
           Transmision();
           Encapsular('B', 'p', '1', '2',0x00,0x00);
           Transmision();
           Encapsular('B', 'p', '1', '3',0x00,0x00);
           Transmision();
           Encapsular('B', 'p', '1', '4',0x00,0x00);
           Transmision();
           recorrer_datos(2);
        }
     }
     if (canal1->bestado && canal2->bestado){
        Encapsular('L', 'p', '1', '0',0x00,0x00);
        Transmision();
        if (ch1_muestreado && ch2_muestreado){
           Encapsular('A', 'p', '1', '1',0x00,0x00);
           Transmision();
           Encapsular('A', 'p', '1', '2',0x00,0x00);
           Transmision();
           Encapsular('A', 'p', '1', '3',0x00,0x00);
           Transmision();
           Encapsular('A', 'p', '1', '4',0x00,0x00);
           Transmision();
           Encapsular('B', 'p', '1', '1',0x00,0x00);
           Transmision();
           Encapsular('B', 'p', '1', '2',0x00,0x00);
           Transmision();
           Encapsular('B', 'p', '1', '3',0x00,0x00);
           Transmision();
           Encapsular('B', 'p', '1', '4',0x00,0x00);
           Transmision();
           recorrer_datos(3);
        }
     }
    Fl::repeat_timeout(0.0005, cb_timer_vectores, this); 
}



/**
 * La función recorrer_datos recorre el arreglo idatos y envia punto 
 * por punto los datos para graficar.
*/
void Osciloscopio::recorrer_datos(int num_canal){
     int icont;
     if (num_canal == 1){
     opantalla->TraceColour(Fl_Color(canal1->ncolor));
     free(opantalla->ScopeData2);
        if (omenu_t_div->value()<6){
           idato_graf_ch1 = idato_osc_ch1;
           opantalla->Add((canal1->opos_x->value()*257)+(idato_graf_ch1*257)); //es
        }
        else{
             for(icont=0;icont < DATA_OSC-1; icont++){
                 idato_graf_ch1 = buf_osc_ch1[icont];
                      opantalla->Add((canal1->opos_x->value()*257)+(idato_graf_ch1*257)); //es            
             }   
        }                
     }
     if (num_canal == 2){
     opantalla->TraceColour(Fl_Color(canal2->ncolor));
     free(opantalla->ScopeData);
        if (omenu_t_div->value()<6){
           idato_graf_ch2 = idato_osc_ch2;
           opantalla->Add((canal2->opos_x->value()*257)+(idato_graf_ch2*257)); //es
        }
        else{
            for(icont=0;icont < DATA_OSC-1; icont++){ 
                idato_graf_ch2 = buf_osc_ch2[icont];
                opantalla->Add((canal2->opos_x->value()*257)+(idato_graf_ch2*257)); //es
            }
        }                 
     }
     if (num_canal == 3){
        if (omenu_t_div->value()<6){
           opantalla->TraceColour(Fl_Color(canal2->ncolor));           
           idato_graf_ch2 = idato_osc_ch2;
           idato_graf_ch1 = idato_osc_ch1; 
           if (osuma->value()){
              opantalla->Add((canal1->opos_x->value()*257)+((idato_graf_ch2*257)+(idato_graf_ch1*257))); //es
           }
           else if(oresta->value()){
              opantalla->Add((canal1->opos_x->value()*257)+((idato_graf_ch2*257)-(idato_graf_ch1*257))); //es  
           }
           else if (ox_y->value()){
                opantalla->Add((canal1->opos_x->value()*257)+(idato_graf_ch1*257),(canal2->opos_x->value()*257)+(idato_graf_ch2*257)); //es
           }
           else if (~osuma->value() && ~oresta->value() && ~ox_y->value()){
                opantalla->bch1 = 1;
                opantalla->bch2 = 1;
                opantalla->Add((canal1->opos_x->value()*257)+(idato_graf_ch1*257),(canal2->opos_x->value()*257)+(idato_graf_ch2*257)); //es
           }
        }
        else{
            for(icont=0;icont < DATA_OSC-1; icont++){
                idato_graf_ch1 = buf_osc_ch1[icont];
                idato_graf_ch2 = buf_osc_ch2[icont];
                if (osuma->value()){
                   opantalla->Add((canal1->opos_x->value()*257)+((idato_graf_ch2*257)+(idato_graf_ch1*257))); //es                
                }
                else if (oresta->value()){
                   opantalla->Add((canal1->opos_x->value()*257)+((idato_graf_ch2*257)-(idato_graf_ch1*257))); //es                
                }
                else if (ox_y->value()){
                   opantalla->Add((canal1->opos_x->value()*257)+(idato_graf_ch1*257),(canal2->opos_x->value()*257)+(idato_graf_ch2*257)); //es               
                }
                else if (~osuma->value() && ~oresta->value() && ~ox_y->value()){
                     opantalla->Add((canal1->opos_x->value()*257)+(idato_graf_ch1*257),(canal2->opos_x->value()*257)+(idato_graf_ch2*257)); //es
                }
            }              
        }                   
     }      
}


/**
 * Este método es el callback del boton que activa el almacenamiento en 
 * archivos planos de texto de los datos capturados para el osciloscopio,  
 * debe ir acompañada de una función inline para poder realizar los callbacks. 
*/
void Osciloscopio::cb_log_osc(Fl_Widget* pboton, void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_log_osc_in();
}

/**
 * Esta función acompaña la función  cb_log_osc para realizar los 
 * llamados de callback del boton que activa el almacenamiento en archivos
 * planos de texto de los datos capturados para el osciloscopio. 
*/
void Osciloscopio::cb_log_osc_in(){
     archivar();
}


/**
 * Rutina para solicitar las muestras de las señales en el osciloscopio. 
*/
void Osciloscopio::muestreo_timer(int isel){
     if (isel==1){
        Fl::add_timeout(0.1, cb_timer_vectores, this);
     }
     else
        Fl::add_timeout(0.1, cb_timer, this);
}


/**
 * Este método es el callback del boton selector de acople
 * del canal del osciloscopio debe ir acompañada de una función 
 * inline para poder realizar los callbacks. 
*/
void Osciloscopio::cb_acople(Fl_Widget* pboton, void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;       
     posc->cb_acople_in();
}


/**
 * Esta función acompaña la función  cb_acople  
 * para realizar los llamados de callback del selector de acople
 * del canal en el osciloscopio 
*/
void Osciloscopio::cb_acople_in(){
  if (isec_acople==0){
     canal1->oacop_gnd->value(0);
     Encapsular('A', 'e', '1', '2',0x00,0x00);
     Transmision();
     if (bhardware){
        canal1->oacop_ac->value(1);
     }
     else{
         fl_message("Error de hardware"); 
     }
  }
  if (isec_acople==1){
     canal1->oacop_ac->value(0);
     Encapsular('A', 'e', '1', '1',0x00,0x00);
     Transmision();
     if (bhardware){
        canal1->oacop_dc->value(1);
     }
     else{
         fl_message("Error de hardware"); 
     }
  }
  if (isec_acople==2){
     canal1->oacop_dc->value(0);
     Encapsular('A', 'e', '1', '3',0x00,0x00);
     Transmision();
      if (bhardware){
         canal1->oacop_gnd->value(1);
      }
     else{
         fl_message("Error de hardware"); 
     }
     isec_acople=-1;
  }
     isec_acople++;  
}



/**
 * Callbacks para modificar el menu de tiempos por division de acuerdo a como 
 * se modifique la perilla selectora de tiempos por division en el osciloscopio. 
*/

void Osciloscopio::cb_tdiv05s(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv05s_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}

void Osciloscopio::cb_tdiv02s(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv02s_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}


void Osciloscopio::cb_tdiv01s(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv01s_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}


void Osciloscopio::cb_tdiv50ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv50ms_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}


void Osciloscopio::cb_tdiv20ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv20ms_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}


void Osciloscopio::cb_tdiv10ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv10ms_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}

void Osciloscopio::cb_tdiv5ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv5ms_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}


void Osciloscopio::cb_tdiv2ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv2ms_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}


void Osciloscopio::cb_tdiv1ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector); 
}

void Osciloscopio::cb_tdiv1ms_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}



void Osciloscopio::cb_tdiv05ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv05ms_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}

void Osciloscopio::cb_tdiv02ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv02ms_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}



void Osciloscopio::cb_tdiv01ms(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv01ms_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}


void Osciloscopio::cb_tdiv50us(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv50us_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}


void Osciloscopio::cb_tdiv20us(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector); 
}

void Osciloscopio::cb_tdiv20us_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}

void Osciloscopio::cb_tdiv10us(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv10us_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}

void Osciloscopio::cb_tdiv5us(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv5us_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}


void Osciloscopio::cb_tdiv2us(Fl_Widget* psel, void *pany){
    Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector); 
}

void Osciloscopio::cb_tdiv2us_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}

void Osciloscopio::cb_tdiv1us(Fl_Widget* psel, void *pany){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tdiv05s_in(pselector);
}

void Osciloscopio::cb_tdiv1us_in(Fl_Widget* psel){
     Fl_Choice *pselector = (Fl_Choice *)psel;
     otiempo_div->value(pselector->value());
}

// Class automatically generated by Dev-C++ New Class wizard

#include "osciloscopio.h" // class's header file
#include <FL/Fl.H>

int isec_ch;              // Variable global para realizar la secuencia de la selección de canales 
int isec_dual;            // Variable global para realizar la secuencia del menu dual 
int isec_trigger;         // Variable global para realizar la secuencia del menu dual 


// class constructor
Osciloscopio::Osciloscopio(int x, int y, int w, int h, const char *l, int ncol):Instrumento()
{
    icolor = ncol;
    strcpy(cnombre,"osc.txt");  
            
    opantalla = new Fl_Scope(8,8,380, 304,"");  // Instancia de scope
    opantalla ->TraceColour(FL_WHITE);
    opantalla->tracetype(FL_SCOPE_TRACE_LOOP);
    opantalla->redrawmode(FL_SCOPE_REDRAW_FULL);
    opantalla->linetype(FL_SCOPE_LINE);
    
    oosc_on = new Fl_Light_Button(650,340,30,20,"ON");
    oosc_on->labelsize(9);
                
    ogroup_osc = new Fl_Group (5,5,680,360,"");    // Agrupa los elementos del osciloscopio
    ogroup_osc->box(FL_ENGRAVED_FRAME); 
    ogroup_osc->deactivate();
    canal1 = new Canal(400,9,130,230,"",100); 
    canal2 = new Canal(545,9,130,230,"",250);
    osel_ch = new Fl_Repeat_Button(110,335,40,18,"Canal");
    osel_ch->labelsize(10);
    och1 = new Fl_Light_Button(160,340,10,10,"CH1");
    och1->labelsize(10);
    och1->box(FL_NO_BOX);
    och1->align(FL_ALIGN_TOP);
    och2 = new Fl_Light_Button(185,340,10,10,"CH2");
    och2->labelsize(10);
    och2->box(FL_NO_BOX);
    och2->align(FL_ALIGN_TOP);
    odual_menu = new Fl_Repeat_Button(230,335,40,18,"Dual");
    odual_menu->labelsize(10);
    odual_menu->deactivate();
    osuma = new Fl_Light_Button(290,340,10,10,"Suma");
    osuma->labelsize(10);
    osuma->box(FL_NO_BOX);
    osuma->align(FL_ALIGN_TOP);
    oresta = new Fl_Light_Button(325,340,10,10,"Resta");
    oresta->labelsize(10);
    oresta->box(FL_NO_BOX);
    oresta->align(FL_ALIGN_TOP);
    ox_y = new Fl_Light_Button(355,340,10,10,"X_Y");
    ox_y->labelsize(10);
    ox_y->box(FL_NO_BOX);
    ox_y->align(FL_ALIGN_TOP);
    olog_osc  = new Fl_Button (15,320,40,18,"Log");
    olog_osc->labelsize(10);
    ohelp_osc  = new Fl_Button (15,342,40,18,"Help");
    ohelp_osc->labelsize(10);
    ogroup_osc->end();  
    
    ogroup_tdiv = new Fl_Group (400,243,240,115,"");    //Agrupa los controles de tiempo por división
    ogroup_tdiv->box(FL_ENGRAVED_FRAME);
    ogroup_tdiv->deactivate();
    otiempo_div = new Fl_Knob (405,250,70,70,"T_DIV");
    otiempo_div->color(147);
    otiempo_div->type(8);
    otiempo_div->labelsize(9);
    otiempo_div->scaleticks(17);
    otiempo_div->range(0,17);
    omenu_t_div = new Fl_Choice(415,335,50,20,"");
    omenu_t_div->add("0.5 s");
    omenu_t_div->add("0.2 s");
    omenu_t_div->add("0.1 s");
    omenu_t_div->add("50 m");
    omenu_t_div->add("20 m");
    omenu_t_div->add("10 m");
    omenu_t_div->add("5 m");
    omenu_t_div->add("2 m");
    omenu_t_div->add("1 m");
    omenu_t_div->add("0.5 m");
    omenu_t_div->add("0.2 m");
    omenu_t_div->add("0.1 m");
    omenu_t_div->add("50 u");
    omenu_t_div->add("20 u");
    omenu_t_div->add("10 u");
    omenu_t_div->add("5 u");
    omenu_t_div->add("2 u");
    omenu_t_div->add("1 u");            
    opos_y = new Fl_Knob (495,255,50,50,"X-Pos");
    opos_y->color(180);
    opos_y->scaleticks(0);
    opos_y->cursor(40);
    opos_y->range(0,10);
    ov_posx = new Fl_Value_Output(500,335,50,20,"");
    osel_trigger = new Fl_Repeat_Button(580,310,40,18,"Trigger");  
    osel_trigger->labelsize(10);
    otrigger_ch1 = new Fl_Light_Button(580,275,10,10,"Ch1");
    otrigger_ch1->labelsize(10);
    otrigger_ch1->box(FL_NO_BOX);
    otrigger_ch1->align(FL_ALIGN_RIGHT);
    otrigger_ch2 = new Fl_Light_Button(580,295,10,10,"Ch2");
    otrigger_ch2->labelsize(10);
    otrigger_ch2->box(FL_NO_BOX);
    otrigger_ch2->align(FL_ALIGN_RIGHT);
    ogroup_tdiv->end();
                
    osel_ch->callback(cb_sel_ch, this);
    odual_menu->callback(cb_dual_menu, this);    
    osel_trigger->callback(cb_sel_trigger, this);
    otiempo_div->callback(cb_tiempo_div, this);
    opos_y->callback(cb_pos_y, this);
    oosc_on->callback(cb_osc_on, this);
    olog_osc->callback(cb_log_osc, this);
}


// class destructor
Osciloscopio::~Osciloscopio()
{
	// insert your code here
}

// sets the value of bsuma
void Osciloscopio::Setbsuma(bool bx)
{
	bsuma = bx;
}

// sets the value of bx_y
void Osciloscopio::Setbx_y(bool bx)
{
	bx_y = bx;
}

// sets the value of ipos_x
void Osciloscopio::Setipos_x(int ix)
{
	ipos_x = ix;
}

// sets the value of it_div
void Osciloscopio::Setit_div(int ix)
{
	it_div = ix;
}

// sets the value of ifrec_muestreo
void Osciloscopio::Setifrec_muestreo(int ix)
{
	ifrec_muestreo = ix;
}

// sets the value of nnivel_trigger
void Osciloscopio::Setinivel_trigger(int ix)
{
	inivel_trigger = ix;
}

// sets the value of bdual
void Osciloscopio::Setbdual(bool bx)
{
	bdual = bx;
}

/*
 * Método para sumar las señales adquiridas por los 2 canales
 * del instrumento.
 */
void Osciloscopio::sumar(int idato1[], int idato2[])
{
     int icont1;
     for (icont1=0; icont1 < inum_datos; icont1++){
         idatos[icont1] = idato1[icont1]+idato2[icont1]; // Suma de las dos señales para el eje y
     }
}

/*
 * Método para restar las señales adquiridas por los 2 canales
 * del instrumento 
 */
void Osciloscopio::restar(int idato1[], int idato2[])
{
     int icont1;
     for (icont1=0; icont1 < inum_datos; icont1++){
         idatos[icont1] = idato1[icont1] - idato2[icont1];    //Diferencia de las dos señales para el eje y
     }
}

/*
 * Método para realizar gráficas de lissajous con las señales 
 * de los 2 canales.
 */
void Osciloscopio::lissajous(int idato1[], int idato2[])
{
     int icont1;
     for (icont1=0; icont1 < inum_datos; icont1++){
         idatos[icont1] = idato1[icont1];                     //Datos del canal 1 para el eje y
     }
}

/**
 * Este método es el callback del boton que enciende el osciloscopio 
 * debe ir acompañada de una función inline para poder realizar los callbacks. 
*/
void Osciloscopio::cb_osc_on(Fl_Widget* pboton, void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;       //
     posc->cb_osc_on_in();
}

/**
 * Esta función acompaña la función  cb_osc_on 
 * para realizar los llamados de callback del boton que enciende
 * el osciloscopio 
*/
void Osciloscopio::cb_osc_on_in(){
      if (oosc_on->value()== 1){
        activar(1);
        ogroup_osc->activate(); 
        ogroup_tdiv->activate();
      
        och1->value(1);
        canal1->activar(1);
        canal1->ogroup_ch->activate();
        Fl::add_timeout(0.5, cb_timer_ch1, this);
     }
     if (oosc_on->value()== 0){
        Fl::remove_timeout(cb_timer_ch2, this);
        Fl::remove_timeout(cb_timer_ch1, this);
        activar(0);
        ogroup_osc->deactivate(); 
        ogroup_tdiv->deactivate();
     }
     isec_ch++;
}

/*
 * Este método es el callback del boton selector de canales
 * en el osciloscopio
 */
void Osciloscopio::cb_sel_ch(Fl_Widget* pboton, void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;       
     posc->cb_sel_ch_in();
}

/**
* Esta función acompaña la función  cb_sel_ch 
* para realizar los llamados de callback del selector de canales
* en el osciloscopio 
*/
void Osciloscopio::cb_sel_ch_in(){
     if (isec_ch==0){
     och2->value(0);
     Fl::remove_timeout(cb_timer_ch2, this);
     canal2->ogroup_ch->deactivate();
     odual_menu->deactivate();
     och1->value(1);
     canal1->activar(1);
     canal1->ogroup_ch->activate();
     Fl::add_timeout(0.5, cb_timer_ch1, this);
     }
     if (isec_ch==1){
     och1->value(0);
     canal1->activar(0);
     canal1->ogroup_ch->deactivate();
     Fl::remove_timeout(cb_timer_ch1, this);
     och2->value(1);
     canal2->activar(1);
     canal2->ogroup_ch->activate();
     Fl::add_timeout(0.2, cb_timer_ch2, this);
     }
     if (isec_ch==2){
     Fl::remove_timeout(cb_timer_ch2, this);
     Fl::remove_timeout(cb_timer_ch1, this);
     och1->value(1);
     canal1->activar(1);
     canal1->ogroup_ch->activate();
     Fl::add_timeout(0.5, cb_timer_dual_ch, this);
     odual_menu->activate();
     isec_ch=-1;
     }
     isec_ch++;
}

/**
 * Este método es el callback del boton del menu de las funciones
 * duales de graficas en el osciloscopio, debe ir acompañada de una 
 * función inline para poder realizar los callbacks. 
*/
void Osciloscopio::cb_dual_menu(Fl_Widget* pboton, void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_dual_menu_in();
}

/**
 * Esta función acompaña la función  cb_menu_dual 
 * para realizar los llamados de callback del menu de funciones duales
 * de graficas en el osciloscopio 
*/
void Osciloscopio::cb_dual_menu_in(){
     if (isec_dual==0){
     ox_y->value(0);
     osuma->value(1);
     }
     if (isec_dual==1){
     osuma->value(0);
     oresta->value(1);
     }
     if (isec_dual==2){
     oresta->value(0);
     ox_y->value(1);
     isec_dual=-1;
     }
     isec_dual++;
}

/**
 * Este método es el callback del boton selector de la fuente del 
 * disparo (trigger) en el osciloscopio, debe ir acompañada de una 
 * función inline para poder realizar los callbacks.  
*/
void Osciloscopio::cb_sel_trigger(Fl_Widget* pboton, void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_sel_trigger_in();
}

/**
 * Esta función acompaña la función  cb_sel_trigger para realizar 
 * los llamados de callback del boton selector de la fuente del
 * trigger en el osciloscopio 
*/
void Osciloscopio::cb_sel_trigger_in(){
     if (isec_trigger==0){
     otrigger_ch2->value(0);
     otrigger_ch1->value(1);
     }
     if (isec_trigger==1){
     otrigger_ch1->value(0);
     otrigger_ch2->value(1);
     isec_trigger=-1;
     }
     isec_trigger++;
}

/**
 * Este método es el callback del boton selector de la escala de 
 * tiempo por división en el osciloscopio, debe ir acompañada de una 
 * función inline para poder realizar los callbacks.  
*/
void Osciloscopio::cb_tiempo_div(Fl_Widget* psel, void *pany)
{
     Fl_Knob *pselector = (Fl_Knob *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_tiempo_div_in(pselector);
}

/**
 * Esta función acompaña la función  cb_tiempo_div 
 * para realizar los llamados de callback del boton selector de la
 * escala de tiempo por división en el osciloscopio 
*/
void Osciloscopio::cb_tiempo_div_in(Fl_Widget* psel){
     Fl_Knob *pselector = (Fl_Knob *)psel;
     pselector->value(floor(pselector->value()));
     omenu_t_div->value(pselector->value());
}

/**
 * Este método es el callback del boton selector de la posición 
 * de la señal respecto al eje y en el osciloscopio, debe ir acompañada 
 * de una función inline para poder realizar los callbacks.  
*/
void Osciloscopio::cb_pos_y(Fl_Widget* psel, void *pany)
{
     Fl_Knob *pselector = (Fl_Knob *)psel;
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_pos_y_in(pselector);
}

/**
 * Esta función acompaña la función  cb_pos_y 
 * para realizar los llamados de callback del boton selector de la
 * posición de la señal respecto al eje y en el osciloscopio 
*/
void Osciloscopio::cb_pos_y_in(Fl_Widget* psel){
     Fl_Knob *pselector = (Fl_Knob *)psel;
     pselector->value(floor(pselector->value()));
     ov_posx->value(pselector->value());
}

/**
 * Este método es el callback del timer para realizar la solicitud 
 * de datos del canal 1 del osciloscopio al hardware.  
*/
void Osciloscopio::cb_timer_ch1(void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_timer_ch1_in();
}

/**
 * Esta función acompaña la función cb_timer_ch1
 * para realizar los llamados de callback del timer 
*/
void Osciloscopio::cb_timer_ch1_in(){
     canal1->Encapsular('A','P','1','0');
     canal1->Transmision();
     canal1->almacenar(canal1->itamano_trama,canal1->buf_osc_ch1);
     recorrer_datos();
     Fl::repeat_timeout(0.2, cb_timer_ch1, this);
}

/**
 * Este método es el callback del timer para realizar la solicitud 
 * de datos del canal 2 del osciloscopio al hardware.  
*/
void Osciloscopio::cb_timer_ch2(void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_timer_ch2_in();
}

/**
 * Esta función acompaña la función cb_timer_ch2
 * para realizar los llamados de callback del timer 
*/
void Osciloscopio::cb_timer_ch2_in(){
     canal2->Encapsular('A','P','1','0');
     canal2->Transmision();
     canal2->almacenar(canal2->itamano_trama,canal2->buf_osc_ch2);
     recorrer_datos();
     Fl::repeat_timeout(0.2, cb_timer_ch2, this);
}

/**
 * Este método es el callback del timer para realizar la solicitud 
 * de datos de los 2 canales del osciloscopio simultaneamente al hardware.  
*/
void Osciloscopio::cb_timer_dual_ch(void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_timer_dual_ch_in();
}

/**
 * Esta función acompaña la función cb_timer_dual_ch
 * para realizar los llamados de callback del timer 
*/
void Osciloscopio::cb_timer_dual_ch_in(){
     canal1->Encapsular('A','P','1','0');
     canal1->Transmision();
     canal1->almacenar(canal1->itamano_trama,canal1->receive_buf_osc);
     canal2->Encapsular('A','P','1','0');
     canal2->Transmision();
     canal2->almacenar(canal2->itamano_trama,canal2->receive_buf_osc);
     recorrer_datos();
     Fl::repeat_timeout(0.2, cb_timer_dual_ch, this);
}

/**
 * La función recorrer_datos recorre el arreglo idatos y envia punto 
 * por punto los datos para graficar.
*/
void Osciloscopio::recorrer_datos()
{
     int icont;
     
     if (canal1->bestado && ~canal2->bestado){
        opantalla->TraceColour(Fl_Color(canal1->ncolor));
        for(icont=0;icont < canal1->inum_datos-1; icont++){
            idato_graf_ch1 = canal1->idatos[icont];
            if (idato_graf_ch1 == 0){
               opantalla->Add(560+ canal1->npos_y);
            }
            else {
                opantalla->Add(canal1->npos_y + (560*(idato_graf_ch1)*canal1->nv_div));
            }              
        }                   
     }
     
     if (canal2->bestado && ~canal1->bestado){
        opantalla->TraceColour(Fl_Color(canal2->ncolor));
        for(icont=0;icont < canal2->inum_datos-1; icont++){
            idato_graf_ch2 = canal2->idatos[icont];
            if (idato_graf_ch2 == 0){
               opantalla->Add(560+ canal2->npos_y);
            }
            else {
                 opantalla->Add(canal2->npos_y + (560*(idato_graf_ch2)*canal2->nv_div));
            }              
        }                   
     }
     
     if (canal2->bestado && canal1->bestado){
        for(icont=0;icont < canal2->inum_datos-1; icont++){
            idato_graf_ch1 = canal1->idatos[icont];
            idato_graf_ch2 = canal2->idatos[icont];
            if (idato_graf_ch2 == 0 || idato_graf_ch1 == 0){
               opantalla->Add((560 + canal1->npos_y), (560 + canal2->npos_y));
            }
            else {
                 opantalla->NumDatos = canal1->inum_datos -1;
                 opantalla->Add(canal1->npos_y + (560*(idato_graf_ch1)*canal1->nv_div),
                 canal2->npos_y + (560*(idato_graf_ch2)*canal2->nv_div));
            }              
        }                   
     }
}


/**
 * Este método es el callback del boton que activa el almacenamiento en 
 * archivos planos de texto de los datos capturados para el osciloscopio,  
 * debe ir acompañada de una función inline para poder realizar los callbacks. 
*/
void Osciloscopio::cb_log_osc(Fl_Widget* pboton, void *pany)
{
     Osciloscopio* posc=(Osciloscopio*)pany;
     posc->cb_log_osc_in();
}

/**
 * Esta función acompaña la función  cb_log_osc para realizar los 
 * llamados de callback del boton que activa el almacenamiento en archivos
 * planos de texto de los datos capturados para el osciloscopio. 
*/
void Osciloscopio::cb_log_osc_in(){
     archivar();
}

